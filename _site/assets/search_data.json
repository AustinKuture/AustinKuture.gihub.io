

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "http://localhost:4000/404.html"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "http://localhost:4000/about/"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "http://localhost:4000/categories/"
    } ,
  
  
  
  
  
    {
      "title"    : "Links",
      "url"      : "http://localhost:4000/links/"
    } ,
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "http://localhost:4000/open-source/"
    } ,
  
  
  
  
  
    {
      "title"    : "Wiki",
      "url"      : "http://localhost:4000/wiki/"
    } ,
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "iOS 监听网络连接状态之AFN",
      "category" : "iOS",
      "content": "iOS 监听网络连接状态之AFN 作者:AustinKuture 摘要: “在网络访问失败的时候，应用没有做出适当的提示”是苹果的iOS审核团队拒绝一个 应用的常见理由。苹果要求你必须先检测网络连接状态，当网络不可用的时候以某种方式 告知用户，或者用其他优雅的方式进行处理。   iOS平台是按照一直有网络连接的思路来设计的，开发者利用这一特点创造了很多优秀的第三方应用。大多数的iOS应用都需要联网，甚至有些应用严重依赖网络，没有网络就无法正常工作。在你的应用尝试通过网络获取数据之前，你需要知道当前设备是否知道连接上了网络，甚至有时候你可能还需要知道当前网路是由wifi还是由移动蜂窝网络提供的。   为了更好的入手和快速的开发需求，本篇主要使用AFN自带方法进行监听网络连接状态，如果想使用原生框架也可以根据苹果官方文档结合自己需求进行开发，苹果官方示例：https://developer.apple.com/library/ios/samplecode/Reachability/Reachability.zip   项目中倒入AFNetworking，引入头文件，并在控制器中加入以下方法即可： - (void)reachability{ AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];  [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {  switch (status) {   case AFNetworkReachabilityStatusUnknown: // 未知网络   NSLog(@未知网络);    break;   case AFNetworkReachabilityStatusNotReachable: // 没有网络(断网)   NSLog(@没有网络(断网));    [self alertView];    break;   case AFNetworkReachabilityStatusReachableViaWWAN: // 手机自带网络   NSLog(@手机自带网络);    break;   case AFNetworkReachabilityStatusReachableViaWiFi: // WIFI   NSLog(@WIFI);    break;  }  }]; [mgr startMonitoring]; }  ",
      "url"      : "http://localhost:4000/2016/11/12/iOS-%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E4%B9%8BAFN/"
    } ,
  
    {
      "title"    : "iOS 之Https自签名证书认证及数据请求的封装",
      "category" : "iOS",
      "content": "iOS 之Https自签名证书认证及数据请求的封装 作者:AustinKuture  摘要: 在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。 App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能， 屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时 关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS。 项目中使用的框架是AFNetworking 3.0及以上版本，由于ATS的原因，iOS只允许使用Https开头的链接，在2016年12月30日以前苹果允许绕开ATS，如下图所示： 但是从2017年1月1日开始将不再接受使用http加载资源的应用，因此本篇文章主要讲解如何使用AFN进行自签名证书的通过认证（注：对于使用CA机构认证的证书不需要进行认证，直接使用Https开头的链接进行数据访问和加载页面即可）项目已经上传至GitHub（需要参考源码的话请点击链接）：https://github.com/AustinKuture/HttpsSignatureCertificate 1，建立一个根类 此处命名为AKNetPackegeAFN 1&gt; .h文件 ,创建所需要的Get 与 Post 方法 import &lt;Foundation/Foundation.h&gt; typedef enum{ AKNetWorkGET , /**&lt; GET请求 */  AKNetWorkPOST = 1 /**&lt; POST请求 */ }AKNetWorkType; typedef void (^HttpSuccess)(id json); typedef void (^HttpErro)(NSError* error); @interface AKNetPackegeAFN : NSObject +(instancetype)shareHttpManager; /* * netWorkType:请求方式 GET 或 POST signature:是否使用签名证书，是的话直接写入证书名字，否的话填nil api:请求的URL接口 parameters:请求参数 sucess:请求成功时的返回值 fail:请求失败时的返回值 * */ - (void)netWorkType:(AKNetWorkType)netWorkType Signature:(NSString *)signature API:(NSString *)api Parameters:(NSDictionary *)parameters Success:(HttpSuccess)sucess Fail:(HttpErro)fail; @end 2&gt; .m文件，导入头文件AFNetworking.h 新建Manager 属性并实现shareHttpManager类方法 #import AKNetPackegeAFN.h #import AFNetworking.h @interface AKNetPackegeAFN() @property (nonatomic,strong) AFHTTPSessionManager *manager; @end @implementation AKNetPackegeAFN +(instancetype)shareHttpManager{  static dispatch_once_t onece = 0;  static AKNetPackegeAFN *httpManager = nil;  dispatch_once(&amp;onece, ^(void){  httpManager = [[self alloc]init];  });  return httpManager; } 2，Get 与Post 方法的实现 使用时将后台所给的证书转换为 .cer格式 拖入项目根目录中，在方法中进行绑定即可例如后台给的证书名为：Kuture.crt 收到证书后双击进行安装，然后打开钥匙串，将名为Kuture的证书右击导出，选择后缀为.cer 然后确定即可 如下图所示：  GET 与 POST 实现方法的封装 - (void)netWorkType:(AKNetWorkType)netWorkType Signature:(NSString *)signature API:(NSString *)api Parameters:(NSDictionary *)parameters Success:(HttpSuccess)sucess Fail:(HttpErro)fail{ //开启证书验证模式  AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; //是否允许使用自签名证书  signature == nil ? (void)(securityPolicy.allowInvalidCertificates = NO):(securityPolicy.allowInvalidCertificates = YES); //是否需要验证域名  securityPolicy.validatesDomainName = NO; _manager = [[AFHTTPSessionManager alloc]initWithBaseURL:[NSURL URLWithString:api]];  _manager.responseSerializer = [AFJSONResponseSerializer serializer];  _manager.securityPolicy = securityPolicy;  _manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@application/json,@application/xml,@text/xml,@text/json,@text/plain,@text/javascript,@text/html, nil]; if (signature != nil){  __weak typeof(self) weakSelf = self;  [_manager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential *__autoreleasing *_credential) {   //获取服务器的 trust object   SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];   //导入自签名证书   NSString *cerPath = [[NSBundle mainBundle] pathForResource:@你的证书名字 ofType:@cer];   NSData *cerData = [NSData dataWithContentsOfFile:cerPath];   if (!cerData) {   NSLog(@==== .cer file is nil ====);   return 0;   }   NSArray *cerArray = @[cerData];   weakSelf.manager.securityPolicy.pinnedCertificates = cerArray;   SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)cerData);   NSCAssert(caRef != nil, @caRef is nil);   NSArray *caArray = @[(__bridge id)(caRef)];   NSCAssert(caArray != nil, @caArray is nil);   //将读取到的证书设置为serverTrust的根证书   OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);   SecTrustSetAnchorCertificatesOnly(serverTrust, NO);   NSCAssert(errSecSuccess == status, @SectrustSetAnchorCertificates failed);   //选择质询认证的处理方式   NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;   __autoreleasing NSURLCredential *credential = nil;   //NSURLAuthenTicationMethodServerTrust质询认证方式   if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {    //基于客户端的安全策略来决定是否信任该服务器，不信任则不响应质询    if ([weakSelf.manager.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {    //创建质询证书    credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];    //确认质询方式    if (credential) {     disposition = NSURLSessionAuthChallengeUseCredential;    } else {     disposition = NSURLSessionAuthChallengePerformDefaultHandling;    }   } else {    //取消挑战    disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;    }   } else {   disposition = NSURLSessionAuthChallengePerformDefaultHandling;   }   return disposition;  }];  } if (netWorkType == 0){  [_manager GET:api parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) {  } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) {   if (sucess){   sucess(responseObject);   }else{   NSLog(@链接异常或网络不存在);   }  } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {   fail(error);  }]; }else if (netWorkType == 1){  [_manager POST:api parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) {  } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) {   if (sucess){   sucess(responseObject);   }else{   NSLog(@链接异常或网络不存在);   }  } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {   fail(error);  }]; } } 3,使用方法，在需要进行数据获取或传递的类里面，直接导入头文件 AKNetPackegeAFN.h ，并实现方法即可，如下所示： //创建对象  //如果是自签名证书，使用前先到AKNetPackegeAFN相应的方法里进行证书的绑定（证书直接拖入项目中）即可  /* * netWorkType:请求方式 GET 或 POST signature:是否使用签名证书，是的话直接写入证书名字，否的话填nil api:请求的URL接口 parameters:请求参数 sucess:请求成功时的返回值 fail:请求失败时的返回值 * */ AKNetPackegeAFN *netHttps = [AKNetPackegeAFN shareHttpManager];  [netHttps netWorkType:请求类型 Signature:证书名称 API:请求URL Parameters:参数 Success:^(id json) {  NSLog(@Json:%@,json);  } Fail:^(NSError *error) {  NSLog(@Error:%@,error);  }]; ",
      "url"      : "http://localhost:4000/2016/12/12/iOS-%E4%B9%8BHttps%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E5%8F%8A%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/"
    } ,
  
    {
      "title"    : "iOS UIWebView 加载自签名证书Https网页",
      "category" : "iOS",
      "content": "iOS UIWebView 加载自签名证书Https网页 作者:AustinKuture 摘要: 在上一篇文章中主要讲解了,如何使用AFN验证自签名证书并加载Https资源数据. 但是对于自签名证书的网页却不能正常加载,本篇文章讲解如何在加载自签名证 书时自动信任证书并加载网页,后续会将如何进行自签名证书的双向认证并加载.   目前源码已经上传至Githup需要参考源码的可以点击这里:https://github.com/AustinKuture/UIWebViewSelfSignedHttps.git   使用UIWebView 加载页面时,我们的常用方法大都是这样的(或者使用WKWebView): UIWebView *webView = [UIWebView alloc]initWithFrame:CGRectMake(0,0,200,200); [webView loadRequest:[NSURLRequest requestWithURL:url]]; [self.view addSubView:webView];   有时我们也会用UIWe不View加载网页时设置Cookie,在这里我们使用NSHTTPCookieStorage实现管理共享的cookie,并将存储一个共享实例,这些Cookie在所有应用程序之间是共享的,并且是跨进程同步保存的,通过对Cookie设置可以让我们像电脑浏览网页一样,灵活的对Cookie信息进行设置和清除,使应用端加载网页信息时更加的方便,Cookie的设置与清除如下所示: //设置Cookie NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary]; [cookieProperties setObject:@cookie_user forKey:NSHTTPCookieName]; [cookieProperties setObject:uid forKey:NSHTTPCookieValue]; [cookieProperties setObject:@xxx.xxx.com forKey:NSHTTPCookieDomain]; [cookieProperties setObject:@/ forKey:NSHTTPCookiePath]; [cookieProperties setObject:@0 forKey:NSHTTPCookieVersion]; [cookieProperties setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires]; NSHTTPCookie *cookieuser = [NSHTTPCookie cookieProperties]; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookieuser]; NSURL *url = [NSURL URLWithString:url];  NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:60]; [webView loadRequest:request]; //清除Cookie - (void)deleteCookie{  NSHTTPCookie *cookie;  NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];  NSArray *cookieAry = [cookieJar cookiesForURL: [NSURL URLWithString: url]];  for (cookie in cookieAry) {  [cookieJar deleteCookie: cookie];  } }   虽然UIWebView使用较为灵活,几乎与电脑端加载网页一样的方便,但是由于种种原因iOS的UIWebView在使用自签名证书加载网页时仍然不能正常的加载数据并显示,对此我们可以使用NSURLConnection和UIWebView的代理方法,实现对自签名证书在一定情况下,自动在程序后台进行验证与自动信任,从而加载出我们所想要显示的网页,具体使用步骤如下: 1,创建一个继承自UIWebView的类AKWebView,在.h文件中添加两个方法,一个是初始化类方法(单例),另一个是WebView的实现方法: #import &lt; UIKit/UIKit.h &gt;  @interface AKWebView : UIWebView +(instancetype)shareWebView;  - (void)webViewWithLoadRequestWithURL:(NSURL *)url Fram:(CGRect)fram; @end 2,在.m文件中,首先添加我们所要用到的代理协议,并创建属性: #import AKWebView.h @interface AKWebView () &lt; UIWebViewDelegate,NSURLConnectionDataDelegate &gt;  @property (nonatomic,strong) NSURLConnection *urlConnection;  @property (nonatomic,strong) NSURLRequest *requestW;  @property (nonatomic) SSLAuthenticate authenticated; @end 3,实现类初始化方法shareWebView: @implementation AKWebView +(instancetype)shareWebView{  static dispatch_once_t onece = 0;  static AKWebView *webView = nil;  dispatch_once( &amp; onece, ^(void){  webView = [[self alloc]init];  });  return webView; } 4,实现webView的实例化方法,在这里主要是为了配置WebVeiw的大小,布局,添加代理,以及Request: #pragma mark ***UIWebView 加载方法*** - (void)webViewWithLoadRequestWithURL:(NSURL *)url Fram:(CGRect)fram{ self.frame = fram;  self.delegate = self;  _requestW = [NSURLRequest requestWithURL:url];  [self loadRequest:_requestW]; } 5,实现各代理方法: #pragma mark ***UIWebView 代理方法*** - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{ NSLog(@开始加载: %@ 授权:%d, [[request URL] absoluteString], _authenticated); if (!_authenticated) {  _authenticated = kNeverAuthenticate;  _urlConnection = [[NSURLConnection alloc] initWithRequest:_requestW delegate:self];  [_urlConnection start];  return NO;  } return YES; } #pragma mark ***NURLConnection 代理方法*** - (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge{  NSLog(@WebController 已经得到授权正在请求 NSURLConnection); if ([challenge previousFailureCount] == 0){  _authenticated = kTryAuthenticate;  NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];  [challenge.sender useCredential:credential forAuthenticationChallenge:challenge]; } else{  [[challenge sender] cancelAuthenticationChallenge:challenge];  } } - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{  NSLog(@WebController 已经收到响应并通过了 NSURLConnection请求); _authenticated = kTryAuthenticate;  [self loadRequest:_requestW];  [_urlConnection cancel]; } - (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpace{ return [protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]; } @end 6,使用方法,在使用时候先导入AKWebView的头文件,在想要加载自签名证书https网页的控制器中,创建AKwebView并实现其方法,添加URL,及Fram大小即可: AKWebView *webView = [AKWebView shareWebView]; [webView webViewWithLoadRequestWithURL:url Fram:CGRectMake(0, 0, 500, 500)]; [self.view addSubview:webView]; ",
      "url"      : "http://localhost:4000/2016/12/27/iOS-UIWebView-%E5%8A%A0%E8%BD%BD%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6Https%E7%BD%91%E9%A1%B5/"
    } ,
  
    {
      "title"    : "iOS 友盟推送通知使用教程",
      "category" : "iOS",
      "content": "iOS 友盟推送通知使用教程 作者:AustinKuture 摘要: 应用中由于系统消息或者即时通讯等功能,经常会用到推送通知, 本篇文章主要讲解如何使用友盟第三方配置到项目中, 最终实现从后台服务器或者友盟服务端进行消息的推送通知. iOS项目中如果要加入推送通知的功能，首先得在开发者中心创建App IDs的时候勾选Push Notifications 的Development 与 Distribution 两个选项开通推送通知的功能，目前网络上有很多关于在开发者中心创建项目证书的博文，对于证书的申请及配置本篇文章不再做过多的介绍。 一，友盟上创建项目并导入开发证书与生产证书 进入友盟官网http://push.umeng.com申请账号并登陆，进入消息推送模块创建应用，根据需要填入相应信息。开发者证书与生产证书创建完成后，需要下载到本地并双击打开，进入钥匙串，找到开发证书与生产证书分别右击导出，输入密码后保存起来。在友盟已经创建的项目中分别上传之前保存的开发证书与生产证书，并输入密码，两个顺序不要弄错，完成后点保存即可。如下图所示：  二，下载并导入SDK 1，下载友盟最新的SDKhttp://dev.umeng.com/push/ios/sdk-download找到SDK文件夹UMessagesdkxx导入到项目中，导入完成后添加库文件UserNotification.framwork 2，打开推送开关： target-&gt;Capbilities-&gt;Push Notifications  需要后台静默通知的话，可以打开以下运程推送：  3，添加代码 打开AppDelegate.m导入以下头文件： #import UMessage.h  #import UserNotifications/UserNotifications.h 在didFinishLaunchingWithOptions方法中添加以下方法： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{  [UMessage startWithAppkey:@5850f2d0310c9364a80018a8 launchOptions:launchOptions httpsenable:YES ];  //注册通知  [UMessage registerForRemoteNotifications];  //iOS10必须加下面这段代码。  UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];  center.delegate=self;  UNAuthorizationOptions types10=UNAuthorizationOptionBadge| UNAuthorizationOptionAlert|UNAuthorizationOptionSound;  [center requestAuthorizationWithOptions:types10  completionHandler:^(BOOL granted, NSError * _Nullable error) {   if (granted) {    //点击允许    //这里可以添加一些自己的逻辑   MyLog(@One);   } else {    //点击不允许    //这里可以添加一些自己的逻辑    MyLog(@Two);   }  }];  //打开日志，方便调试  [UMessage setLogEnabled:YES];  } 4，处理运程，前台及后台通知的方法： //远程推送通知的接收 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{ MyLog(@后台远程推送通知:%@,userInfo); //iOS10新增：处理前台收到通知的代理方法 -(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{ NSDictionary * userInfo = notification.request.content.userInfo;  if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {  //应用处于前台时的远程推送接受  //关闭友盟自带的弹出框  [UMessage setAutoAlert:NO];  //必须加这句代码  [UMessage didReceiveRemoteNotification:userInfo];  MyLog(@前台远程推送通知:%@,userInfo); }else{  //应用处于前台时的本地推送接受  MyLog(@Four);  }  //当应用处于前台时提示设置，需要哪个可以设置哪一个  completionHandler(UNNotificationPresentationOptionSound|UNNotificationPresentationOptionBadge|UNNotificationPresentationOptionAlert); } //iOS10新增：处理后台点击通知的代理方法 -(void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler{ NSDictionary * userInfo = response.notification.request.content.userInfo;  if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {  //应用处于后台时的远程推送接受  //必须加这句代码  [UMessage didReceiveRemoteNotification:userInfo];  MyLog(@后台推送通知:%@,userInfo);  MyLog(@Six);  } } 三，测试模式下通知信息的发送 1，进入友盟管理平台，点击测试模式： 2，添加测试设备，其中Device Token为真机调试时产生的。 3，创建并发送测试消息： 4，完成后点击发送按钮即可 ",
      "url"      : "http://localhost:4000/2016/12/27/iOS-%E5%8F%8B%E7%9B%9F%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"
    } ,
  
    {
      "title"    : "The operation couldn’t be completed. Unable to log in with account",
      "category" : "Bug",
      "content": "The operation couldn’t be completed. Unable to log in with account ‘’ 作者:AustinKuture 摘要: 使用真机登陆时，若出现如下错误则说明账号已经过期，重新登陆开发者账号即可。 errors：The operation couldn’t be completed. Unable to log in  with account 'myappleid'. An unexpected failure occurred while  logging in (Underlying error code 1100). 解决方法：打开Xcode 点击Preference-&gt;Accounts 点击你的开发账号，将登陆已经过期的账号重新登陆，然后重启Xcode即可。 ",
      "url"      : "http://localhost:4000/2017/02/06/The-operation-couldn-t-be-completed.-Unable-to-log-in-with-account/"
    } ,
  
    {
      "title"    : "The operation couldn’t be completed. Unable to log in with",
      "category" : "Bug",
      "content": "Mac Generating Pods project Abort trap: 6 作者:AustinKuture 摘要: 使用cocoapods为项目添加pod库时,发现未产生.xcworkspace文件, 同时终端上显示Generating Pods project Abort trap: 6,本篇文 章主要分析可能产生的原因并找出最适合的方法解决此类问题. 为项目添加cocoapods如果产生此种错误时,主要有以下几点原因: 1,cocoapods版本过低:  打开终端在终端输入:pod –version,目前最新版本是1.2.0(2017年3月),如果发现版本过低,则可以在终端输入以下命令:gem install cocoapods 更新cocoapods工具然后 pod install即可  2,ruby版本过低:  在终端输入:rvm list known查看所有ruby版本  输入ruby -v 查看当前版本  如果不是最新的则输入ruby 2.3.0 install (注:2.30为版本号) 3,使用了过期的ruby镜像:  终端输入:gem sources -l查看当前镜像源  2017年之前国内镜像源一直是 https://ruby.taobao.org/,目前镜像源已由淘宝改为https://gems.ruby-china.org/  更改方法: 1&gt;移除旧的镜像源 , gem sources –remove https://ruby.taobao.org/ 2&gt;添加新的镜像源, gem sources –add https://gems.ruby-china.org/ 完成后查看一下,gem sources -l 4,排除前两种后,更改ruby 镜像源时报错,错误原因为请求拒绝:  当遇见修改镜像遭到拒绝时,说明在安装或者产生根目录时使用了管理员身份进行的操作,解决方法如下: 打开终端输入: sudo -s 以管理员身份运行 输入sudo -s 后系统要求输入密码,密码输入时为不可见状态,直接输入并回车即可.成功获得超级管理员身份后用户名称会变为以下状态: 此时以超级管理员的身份,重复操作步骤3即可修改镜像源. 5,当以上4种情况皆不可行时,卸载ruby环境和cocoapods,并重新安装,安装教程:http://www.jianshu.com/p/6d8604f0b94c ",
      "url"      : "http://localhost:4000/2017/03/01/Mac-Generating-Pods-project-Abort-trap-6/"
    } ,
  
    {
      "title"    : "iOS CGContextAddArcToPoint 绘制带圆角的image图片",
      "category" : "iOS",
      "content": "iOS CGContextAddArcToPoint 绘制带圆角的image图片 作者:AustinKuture 摘要: 在开发中有时需要为UIButton在Normal与Highlighted两种状态下设置不同 颜色的背景图片,这时又缺少现成的图片,则可以使用绘图方法绘制出所需要的图片,同 时使用可以使用CGContextAddArcToPoint绘制圆角.   如果项目中经常需要使用该方法时可以新建一个UIimage的分类,并将方法封装到其分类中.   绘制方法的封装: //绘制指定颜色图片 + (UIImage *)createImageWithColor:(UIColor *)color RectSize:(CGSize)rectSize         CornerRadius:(float)cornerRadius{ //直接绘制图像方法 // CGRect rect=CGRectMake(0.0f, 0.0f, 50.0f, 50.0f); // UIGraphicsBeginImageContext(rect.size); // CGContextRef context = UIGraphicsGetCurrentContext(); // CGContextSetFillColorWithColor(context, [color CGColor]); // CGContextFillRect(context, rect); // UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); // UIGraphicsEndImageContext(); //带圆角图像的绘制方法  UIImage *theImage;  CGRect rect = CGRectMake(0.0f, 0.0f, rectSize.width, rectSize.height); UIGraphicsBeginImageContext(rect.size); //开始画线  [theImage drawInRect:CGRectMake(0, 0, rect.size.width, rect.size.height)];  //获取上下文  CGContextRef context = UIGraphicsGetCurrentContext();  //边框大小  CGContextSetLineWidth(context, 1);  //边框颜色  CGContextSetStrokeColorWithColor(context, COLORS_CLEAR.CGColor);  //矩形填充颜色  CGContextSetFillColorWithColor(context, [color CGColor]); /* * 将要绘制的图像大小,分割成8个点,每两个点可以可以确定一条射线,每两条射线相交处可以设置圆弧. 当前方法中先绘制的右下角, 例如,将要绘制的圆角图片大小为:宽100,高100 圆角5,则需要的点分别为: A(100,10) B(100,100) C(90,100) D(0,100) E(0,90) F(0,0) G(10,0) H(100,0) *  */ //绘制图像及圆角  CGContextMoveToPoint(context, rectSize.width, cornerRadius * 2); // 开始坐标右边开始  CGContextAddArcToPoint(context, rectSize.width, rectSize.height, rectSize.width - 10, rectSize.height, cornerRadius); // 右下角  CGContextAddArcToPoint(context, 0, rectSize.height, 0, rectSize.height - 10, cornerRadius); // 左下角  CGContextAddArcToPoint(context, 0, 0, cornerRadius * 2, 0, cornerRadius); // 左上角  CGContextAddArcToPoint(context, rectSize.width, 0, rectSize.width, cornerRadius * 2, cornerRadius); // 右上角  CGContextDrawPath(context, kCGPathFillStroke); //根据当前坐标绘制路径  theImage = UIGraphicsGetImageFromCurrentImageContext();//获取绘图 //拉伸当前图像  CGFloat h = theImage.size.height * 0.5;  CGFloat w = theImage.size.width * 0.5;  UIImage *rsizeImg = [theImage resizableImageWithCapInsets:UIEdgeInsetsMake(h, w, h, w) resizingMode:UIImageResizingModeStretch]; return rsizeImg; }   使用时方法: UIButton *testBtn = [[UIButton alloc]initWithFrame:CGRectMake(0,0, 85, 40)]; [testBtn setImage:[UIImage createImageWithColor:[UIColor grarColor] RectSize:testBtn.size CornerRadius:5] forState:UIControlStateNormal]; [testBtn setImage:[UIImage createImageWithColor:[UIColor yellowColor] RectSize:testBtn.size CornerRadius:5] forState:UIControlStateHighlighted]   在实际使用时的效果:  ",
      "url"      : "http://localhost:4000/2017/03/16/iOS-CGContextAddArcToPoint-%E7%BB%98%E5%88%B6%E5%B8%A6%E5%9C%86%E8%A7%92%E7%9A%84image%E5%9B%BE%E7%89%87/"
    } ,
  
    {
      "title"    : "iOS 改变字体行间距与字间距",
      "category" : "iOS",
      "content": "iOS 改变字体行间距与字间距 作者:AustinKuture 摘要: UILabel上显示的文本内容,在默认情况下往往会显的非常的拥挤, 特别是存在大量文字的时候,缺少应有的美观,本篇文章主要是通过分类封 装一个类方法,在使用带有大量文字的UILabel时直接调用即可. 1,创建分类并声明所需的类方法 .h文件 #import &lt;UIKit/UIKit.h&gt; @interface UILabel (AKSpace) /** * 改变行间距 */ + (void)changeLineSpaceForLabel:(UILabel *)label WithSpace:(float)space; /** * 改变字间距 */ + (void)changeWordSpaceForLabel:(UILabel *)label WithSpace:(float)space; /** * 改变行间距和字间距 */ + (void)changeSpaceForLabel:(UILabel *)label withLineSpace:(float)lineSpace WordSpace:(float)wordSpace; @end 2,实现类方法 .m文件 #import UILabel+AKSpace.h @implementation UILabel (AKSpace) //改变字体行间距 + (void)changeLineSpaceForLabel:(UILabel *)label WithSpace:(float)space { NSString *labelText = label.text;  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:labelText];  NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  [paragraphStyle setLineSpacing:space];  [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [labelText length])];  label.attributedText = attributedString;  [label sizeToFit]; } //改变字体字间距 + (void)changeWordSpaceForLabel:(UILabel *)label WithSpace:(float)space { NSString *labelText = label.text;  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:labelText attributes:@{NSKernAttributeName:@(space)}];  NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [labelText length])];  label.attributedText = attributedString;  [label sizeToFit]; } //改变字体行间距与间距 + (void)changeSpaceForLabel:(UILabel *)label withLineSpace:(float)lineSpace WordSpace:(float)wordSpace { NSString *labelText = label.text;  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:labelText attributes:@{NSKernAttributeName:@(wordSpace)}];  NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  [paragraphStyle setLineSpacing:lineSpace];  [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [labelText length])];  label.attributedText = attributedString;  [label sizeToFit]; } @end 3,使用方法 UILabel默认排版: 加入行间与字间距后的排版: ",
      "url"      : "http://localhost:4000/2017/03/21/iOS-%E6%94%B9%E5%8F%98%E5%AD%97%E4%BD%93%E8%A1%8C%E9%97%B4%E8%B7%9D%E4%B8%8E%E5%AD%97%E9%97%B4%E8%B7%9D/"
    } ,
  
    {
      "title"    : "iOS 调用本地系统分享",
      "category" : "iOS",
      "content": "iOS 调用本地系统分享 作者:AustinKuture 摘要: 应用中经常会使用分享功能对多媒体内容进行分享， 目前常用的方法是使用第三方平台进行分享， 例如极光、友盟等等，但是使用第三方分享往往意味着要导入SDK， 增加应用复杂程度及管理难度。这里我们使用iOS自带的分享功能对多媒体内容进行分享， 使用自带的分享功能可以大大节省开发时间， 降低维护及管理难度，缺点是可供分享的社交平台较少。 1，实现效果： 2，源码（123.pfd是要分享的文件，可以根据自己需要进行自定义） #import ViewController.h @interface ViewController ()&lt;UIDocumentInteractionControllerDelegate&gt; @property (nonatomic,strong)UIDocumentInteractionController *documentInteractionController; @property (weak, nonatomic) IBOutlet UIButton *openIn; @property (nonatomic,strong) UIButton *shareB; @end @implementation ViewController - (void)viewDidLoad {  [super viewDidLoad]; _shareB = [[UIButton alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width * 0.5 - 75, 250, 150, 50)];  [_shareB setTitle:@Share forState:UIControlStateNormal];  _shareB.backgroundColor = [UIColor grayColor];  [_shareB setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];  [_shareB addTarget:self action:@selector(shareIn:) forControlEvents:UIControlEventTouchUpInside];  [self.view addSubview:_shareB]; } - (IBAction)openIn:(UIButton *)sender {  NSString *localPath = [[NSBundle mainBundle] pathForResource:@123 ofType:@pdf];  NSURL *pathUrl = [[NSURL alloc]initFileURLWithPath:localPath]; // Initialize Document Interaction Controller  self.documentInteractionController = [UIDocumentInteractionController interactionControllerWithURL:pathUrl]; // Configure Document Interaction Controller  [self.documentInteractionController setDelegate:self]; // Present Open In Menu  [self.documentInteractionController presentOptionsMenuFromRect:[self.openIn frame] inView:self.view animated:YES]; } #pragma mark Document Interaction Controller Delegate Methods - (UIViewController *) documentInteractionControllerViewControllerForPreview: (UIDocumentInteractionController *) controller {  return self; } - (void)shareIn:(UIButton *)shareb{  NSString *localPath = [[NSBundle mainBundle] pathForResource:@123 ofType:@pdf];  UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[localPath] applicationActivities:nil];  UIActivityViewControllerCompletionHandler myBlock = ^(NSString *activityType,BOOL completed)  {   NSLog(@调用分享的应用id :%@, activityType);   if (completed)   {    NSLog(@分享成功!);   }   else   {    NSLog(@分享失败!);   }  };  activity.completionHandler = myBlock;  // activity.completionWithItemsHandler = myBlock;  if ([[UIDevice currentDevice].model isEqualToString:@iPhone]) {   [self presentViewController:activity animated:YES completion:nil];  }  else if([[UIDevice currentDevice].model isEqualToString:@iPad])  {   UIPopoverPresentationController *popover = activity.popoverPresentationController;   if (popover) {    popover.sourceView = _shareB;    popover.permittedArrowDirections = UIPopoverArrowDirectionUp;   }   [self presentViewController:activity animated:YES completion:nil];  }  else  {   //do nothing  } } ",
      "url"      : "http://localhost:4000/2017/05/08/iOS-%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E5%88%86%E4%BA%AB/"
    } ,
  
    {
      "title"    : "C 语言获取外网及内网IP",
      "category" : "C",
      "content": "C 语言获取外网及内网IP 作者:AustinKuture 摘要: 移动或网站开发中经常需要设备或网站内网及外网IP, 本篇文章讲解如何使用C语言获取外网及内网IP. 1, 引入头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;net/ethernet.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netdb.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/sockio.h&gt; #include &lt;net/if.h&gt; #include &lt;errno.h&gt; #include &lt;net/if_dl.h&gt; 2,添加所需要的常量 #define min(a,b) ((a) &lt; (b) ? (a) : (b)) #define max(a,b) ((a) &gt; (b) ? (a) : (b)) #define MAXADDRS 32 #define BUFFERSIZE 4000 char *if_names[MAXADDRS]; char *ip_names[MAXADDRS]; char *hw_addrs[MAXADDRS]; unsigned long ip_addrs[MAXADDRS]; static int nextAddr = 0; 3,实现获取内网IP的方法 /* * 获取内网IP */ void InitAddresses(){  int i;  for (i=0; i&lt;MAXADDRS; ++i)  {  if_names[i] = ip_names[i] = hw_addrs[i] = NULL;  ip_addrs[i] = 0;  } } void FreeAddresses(){  int i;  for (i=0; i&lt;MAXADDRS; ++i)  {  if (if_names[i] != 0) free(if_names[i]);  if (ip_names[i] != 0) free(ip_names[i]);  if (hw_addrs[i] != 0) free(hw_addrs[i]);  ip_addrs[i] = 0;  }  InitAddresses(); } void GetIPAddresses(){ int    i, len, flags;  char   buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;  struct ifconf  ifc;  struct ifreq  *ifr, ifrcopy;  struct sockaddr_in *sin; char temp[80]; int sockfd; for (i=0; i&lt;MAXADDRS; ++i)  {  if_names[i] = ip_names[i] = NULL;  ip_addrs[i] = 0;  } sockfd = socket(AF_INET, SOCK_DGRAM, 0);  if (sockfd &lt; 0)  {  perror(socket failed);  return;  } ifc.ifc_len = BUFFERSIZE;  ifc.ifc_buf = buffer; if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &lt; 0)  {  perror(ioctl error);  return;  } lastname[0] = 0; for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )  {  ifr = (struct ifreq *)ptr;  len = max(sizeof(struct sockaddr), ifr-&gt;ifr_addr.sa_len);  ptr += sizeof(ifr-&gt;ifr_name) + len; // for next one in buffer  if (ifr-&gt;ifr_addr.sa_family != AF_INET)  {   continue; // ignore if not desired address family  }  if ((cptr = (char *)strchr(ifr-&gt;ifr_name, ':')) != NULL)  {   *cptr = 0; // replace colon will null  }  if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0)  {   continue; /* already processed this interface */  }  memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ);  ifrcopy = *ifr;  ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy);  flags = ifrcopy.ifr_flags;  if ((flags &amp; IFF_UP) == 0)  {   continue; // ignore if interface not up  }  if_names[nextAddr] = (char *)malloc(strlen(ifr-&gt;ifr_name)+1);  if (if_names[nextAddr] == NULL)  {   return;  }  strcpy(if_names[nextAddr], ifr-&gt;ifr_name);  sin = (struct sockaddr_in *)&amp;ifr-&gt;ifr_addr;  strcpy(temp, inet_ntoa(sin-&gt;sin_addr));  ip_names[nextAddr] = (char *)malloc(strlen(temp)+1);  if (ip_names[nextAddr] == NULL)  {   return;  }  strcpy(ip_names[nextAddr], temp);  ip_addrs[nextAddr] = sin-&gt;sin_addr.s_addr;  ++nextAddr;  } close(sockfd); } void GetHWAddresses(){ struct ifconf ifc;  struct ifreq *ifr;  int i, sockfd;  char buffer[BUFFERSIZE], *cp, *cplim;  char temp[80]; for (i=0; i&lt;MAXADDRS; ++i)  {  hw_addrs[i] = NULL;  } sockfd = socket(AF_INET, SOCK_DGRAM, 0);  if (sockfd &lt; 0)  {  perror(socket failed);  return;  } ifc.ifc_len = BUFFERSIZE;  ifc.ifc_buf = buffer; if (ioctl(sockfd, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0)  {  perror(ioctl error);  close(sockfd);  return;  } ifr = ifc.ifc_req; cplim = buffer + ifc.ifc_len; for (cp=buffer; cp &lt; cplim; )  {  ifr = (struct ifreq *)cp;  if (ifr-&gt;ifr_addr.sa_family == AF_LINK)  {   struct sockaddr_dl *sdl = (struct sockaddr_dl *)&amp;ifr-&gt;ifr_addr;   int a,b,c,d,e,f;   int i;   strcpy(temp, (char *)ether_ntoa(LLADDR(sdl)));   sscanf(temp, %x:%x:%x:%x:%x:%x, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f);   sprintf(temp, %02X:%02X:%02X:%02X:%02X:%02X,a,b,c,d,e,f);   for (i=0; i&lt;MAXADDRS; ++i)   {    if ((if_names[i] != NULL) &amp;&amp; (strcmp(ifr-&gt;ifr_name, if_names[i]) == 0))    {    if (hw_addrs[i] == NULL)    {     hw_addrs[i] = (char *)malloc(strlen(temp)+1);     strcpy(hw_addrs[i], temp);     break;    }    }   }  }  cp += sizeof(ifr-&gt;ifr_name) + max(sizeof(ifr-&gt;ifr_addr), ifr-&gt;ifr_addr.sa_len);  } close(sockfd); } 4,实现获取外网IP的方法 /* * 获取外网IP */ - (char *)getPublicIPAdressWithHostName:(char *)hostName{ int sock;  char **pptr = NULL;  struct sockaddr_in destAddr;  struct hostent *ptr = NULL;  char destIP[128]; sock = socket(AF_INET,SOCK_STREAM,0);  if( -1 == sock ){  perror(creat socket failed);  return false;  }  bzero((void *)&amp;destAddr,sizeof(destAddr));  destAddr.sin_family = AF_INET;  destAddr.sin_port = htons(80);  ptr = gethostbyname(hostName);  if(NULL == ptr){  perror(gethostbyname error);  return false;  }  for(pptr=ptr-&gt;h_addr_list ; NULL != *pptr ; ++pptr){  inet_ntop(ptr-&gt;h_addrtype,*pptr,destIP,sizeof(destIP));  printf(addr:%s  ,destIP);  return destIP;  }  return destIP; } 5,实现方法,此处我们以iOS项目为例,其他兼容C语言的项目同样适用 //返回内网IP的的方法,在需要内网IP的地方直接调用deviceIPAdress方法即可 - (NSString *)deviceIPAdress { InitAddresses();  GetIPAddresses();  GetHWAddresses(); return [NSString stringWithFormat:@%s, ip_names[1]]; } //同理获取外网IP时直接调用- (char *)getPublicIPAdressWithHostName:(char *)hostName方法即可,例如 [NSString stringWithFormat:@%s,[self getPublicIPAdressWithHostName:www.baidu.com]];- ",
      "url"      : "http://localhost:4000/2017/05/31/C-%E8%AF%AD%E8%A8%80%E8%8E%B7%E5%8F%96%E5%A4%96%E7%BD%91%E5%8F%8A%E5%86%85%E7%BD%91IP/"
    } ,
  
    {
      "title"    : "AFN NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806)",
      "category" : "Bug",
      "content": "AFN NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806) 作者: AustinKuture 摘要: 使用AFNetworking请求https链接的数据时, 报错NSURLSession/NSURLConnection HTTP load failed  (kCFStreamErrorDomainSSL, -9806),其原因主要是加密协议版本不... 一, 加密协议不统一 iOS 9之后默认的加密协议是TLSv1.2,目前有些服务端仍然使用的是TLSv1.0,这样就会因为协议不统一而造成应用端与服务端不能建立连接,并报错:Error Domain=NSURLErrorDomain Code=-1200  解决方法有两种:    第一种方法 : 从应用端修改  右击plist文件 -&gt; Open As -&gt; Source Code,在其中加入如下代码:  &lt;key&gt;域名&lt;/key&gt;  &lt;dict&gt;  &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;  &lt;true/&gt;  &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt;  &lt;true/&gt;  &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt;  &lt;string&gt;TLSv1.0&lt;/string&gt;  &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt;  &lt;false/&gt; &lt;/dict&gt;      第二种方法 : 从服务端修改  让服务端将加密协议从TLSv1.0或者TLSv1.1改为TLSv1.2   二, 服务端使用了签名证书  服务端如果使用了未经第三方机构认证的证书,使用afn请求数据时会报错:NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806)   将服务端的三个证书,选择其中一个(例如.crt或者.pem)放在本地双击打开会被添加到钥匙串,从钥匙串导出后缀为.cer的文件,然后拖入到项目中. 打开 Build Phases -&gt; Copy Bunld Resources 查看证书是否已经绑定,如果没有点击 + 号绑定证书.完成后,在请求数据的地方加入Security的设置: AFSecurityPolicy * securityPolicy = [AFSecurityPolicypolicyWithPinningMode:AFSSLPinningModeCertificate];  securityPolicy.allowInvalidCertificates = YES;  securityPolicy.validatesDomainName = NO;  manager.securityPolicy = securityPolicy;  完成后,重新运行即可. ",
      "url"      : "http://localhost:4000/2017/06/16/AFN-NSURLSessionNSURLConnection-HTTP-load-failed-(kCFStreamErrorDomainSSL,-9806)/"
    } ,
  
    {
      "title"    : "Ios开发技巧(一)",
      "category" : "",
      "content": "iOS开发技巧(一) 1、禁止手机睡眠 [UIApplication sharedApplication].idleTimerDisabled = YES; 2、隐藏某行cell - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { // 如果是你需要隐藏的那一行，返回高度为0  if(indexPath.row == YouWantToHideRow)  return 0; return 44; } // 然后再你需要隐藏cell的时候调用 [self.tableView beginUpdates]; [self.tableView endUpdates]; 3、禁用button高亮 button.adjustsImageWhenHighlighted = NO; 或者在创建的时候 UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 4、tableview遇到这种报错failed to obtain a cell from its dataSource 是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了 可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识 5、cocoa pods报这个错误：unable to access ‘https://github.com/facebook/pop.git/’: Operation timed out after 0 milliseconds with 0 out of 0 bytes received 解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了 6、cocoa pods 出现ERROR: While executing gem … (Errno::EPERM) 解决办法：https://segmentfault.com/q/1010000002926243 7、动画切换window的根控制器 // options是动画选项 [UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{  BOOL oldState = [UIView areAnimationsEnabled];  [UIView setAnimationsEnabled:NO];  [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];  [UIView setAnimationsEnabled:oldState];  } completion:^(BOOL finished) {  }]; 8、去除数组中重复的对象 NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self]; 9、编译的时候遇到 no such file or directory: ／users／apple／XXX 是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可 10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题 11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑 // 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行 - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { } 12、三个通知 NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化 UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用） 13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。 14、上线前注意：  1）、删掉代码中所有的测试代码 2）、如果后台有审核模式，提醒后台开启此模式 3）、主流程再跑一跑 4）、全局搜索waring，检查所有标记waring的地方 15、跳进app权限设置 // 跳进app设置 if (UIApplicationOpenSettingsURLString != NULL) {  NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];  [[UIApplication sharedApplication] openURL:url]; } 16、给一个view截图 UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0); [view.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); 17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。 18、注意对象为nil的时候，调用此对象分类的方法不会执行 19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动： collectionView.alwaysBounceHorizontal = YES; collectionView.alwaysBounceVertical = YES; 20、设置navigationBar上的title颜色和大小 [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}] 21、颜色转图片 + (UIImage *)cl_imageWithColor:(UIColor *)color { CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 22、view设置圆角 #define ViewBorderRadius(View, Radius, Width, Color)      [View.layer setCornerRadius:(Radius)];   [View.layer setMasksToBounds:YES];   [View.layer setBorderWidth:(Width)];   [View.layer setBorderColor:[Color CGColor]] // view圆角 23、强／弱引用 #define WeakSelf(type) __weak typeof(type) weak##type = type; // weak #define StrongSelf(type) __strong typeof(type) type = weak##type; // strong 24、由角度转换弧度 #define DegreesToRadian(x) (M_PI * (x) / 180.0) 25、由弧度转换角度 #define RadianToDegrees(radian) (radian*180.0)/(M_PI) 26、获取图片资源 #define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@%@,imageName]] 27、获取temp #define PathTemp NSTemporaryDirectory() 28、获取沙盒 Document #define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] 29、获取沙盒 Cache #define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] 30、GCD代码只执行一次 #define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock); 31、自定义NSLog #ifdef DEBUG #define NSLog(fmt, ...) NSLog((@%s [Line %d] fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__) #else #define NSLog(...) #endif 32、Font #define FontL(s)   [UIFont systemFontOfSize:s weight:UIFontWeightLight] #define FontR(s)   [UIFont systemFontOfSize:s weight:UIFontWeightRegular] #define FontB(s)   [UIFont systemFontOfSize:s weight:UIFontWeightBold] #define FontT(s)   [UIFont systemFontOfSize:s weight:UIFontWeightThin] #define Font(s)   FontL(s) 33、FORMAT #define FORMAT(f, ...) [NSString stringWithFormat:f, ## __VA_ARGS__] 34、在主线程上运行 #define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock); 35、开启异步线程 #define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl); 36、通知 #define NOTIF_ADD(n, f)  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil] #define NOTIF_POST(n, o) [[NSNotificationCenter defaultCenter] postNotificationName:n object:o] #define NOTIF_REMV()  [[NSNotificationCenter defaultCenter] removeObserver:self] 37、随机颜色 + (UIColor *)RandomColor {  NSInteger aRedValue = arc4random() % 255;  NSInteger aGreenValue = arc4random() % 255;  NSInteger aBlueValue = arc4random() % 255;  UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];  return randColor; } 38、获取window +(UIWindow*)getWindow {  UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow;  for (id item in [UIApplication sharedApplication].windows) {  if ([item class] == [UIWindow class]) {   if (!((UIWindow*)item).hidden) {    win = item;    break;   }  }  }  return win; } 39、修改textField的placeholder的字体颜色、大小 [textField setValue:[UIColor redColor] forKeyPath:@_placeholderLabel.textColor]; [textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@_placeholderLabel.font]; 40、统一收起键盘 [[[UIApplication sharedApplication] keyWindow] endEditing:YES]; 41、控制屏幕旋转，在控制器中写 /** 是否支持自动转屏 */ - (BOOL)shouldAutorotate {  return YES; } /** 支持哪些屏幕方向 */ - (UIInterfaceOrientationMask)supportedInterfaceOrientations {  return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight; } /** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */ - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {  return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight; } 42、获取app缓存大小 - (CGFloat)getCachSize { NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];  //获取自定义缓存大小  //用枚举器遍历 一个文件夹的内容  //1.获取 文件夹枚举器  NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@Library/Caches];  NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];  __block NSUInteger count = 0;  //2.遍历  for (NSString *fileName in enumerator) {  NSString *path = [myCachePath stringByAppendingPathComponent:fileName];  NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];  count += fileDict.fileSize;//自定义所有缓存大小  }  // 得到是字节 转化为M  CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;  return totalSize; } 43、清理app缓存 - (void)handleClearView {  //删除两部分  //1.删除 sd 图片缓存  //先清除内存中的图片缓存  [[SDImageCache sharedImageCache] clearMemory];  //清除磁盘的缓存  [[SDImageCache sharedImageCache] clearDisk];  //2.删除自己缓存  NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@Library/Caches];  [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil]; } 44、模型转字典 static NSSet *classes; - (NSMutableDictionary *)getParameterDictionary { NSMutableDictionary *dict = [NSMutableDictionary dictionary]; Class c = self.class; while (c) {  unsigned count;  objc_property_t *properties = class_copyPropertyList([c class], &amp;count);  for (int i = 0; i &lt; count; i++) {   NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];   dict[key] = [self valueForKey:key];  }  free(properties);  // 获得父类  c = class_getSuperclass(c);  if ([self isClassFromFoundation:c]) break;  }  return dict; } - (BOOL)isClassFromFoundation:(Class)c {  if (c == [NSObject class] || c == [NSManagedObject class]) return YES; __block BOOL result = NO;  [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {  if ([c isSubclassOfClass:foundationClass]) {   result = YES;   *stop = YES;  }  }];  return result; } - (NSSet *)foundationClasses {  if (classes == nil) {  // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断  classes = [NSSet setWithObjects:      [NSURL class],      [NSDate class],      [NSValue class],      [NSData class],      [NSError class],      [NSArray class],      [NSDictionary class],      [NSString class],      [NSAttributedString class], nil];  }  return classes; } 45、交换两个方法实现 Class aClass = [self class];   SEL originalSelector = @selector(viewWillAppear:);  SEL swizzledSelector = @selector(xxx_viewWillAppear:);   Method originalMethod = class_getInstanceMethod(aClass, originalSelector);  Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector);   BOOL didAddMethod =   class_addMethod(aClass,   originalSelector,   method_getImplementation(swizzledMethod),   method_getTypeEncoding(swizzledMethod));   if (didAddMethod) {   class_replaceMethod(aClass,   swizzledSelector,   method_getImplementation(originalMethod),   method_getTypeEncoding(originalMethod));  } else {   method_exchangeImplementations(originalMethod, swizzledMethod);  } 46、打印百分号和引号 NSLog(@%%); NSLog(@  ); 47、几个常用权限判断 if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {  NSLog(@没有定位权限); } AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (statusVideo == AVAuthorizationStatusDenied) {  NSLog(@没有摄像头权限); } //是否有麦克风权限 AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; if (statusAudio == AVAuthorizationStatusDenied) {  NSLog(@没有录音权限); } [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {  if (status == PHAuthorizationStatusDenied) {  NSLog(@没有相册权限);  } }]; 48、获取手机型号 + (NSString *)getDeviceInfo { struct utsname systemInfo; uname(&amp;systemInfo); NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding]; if ([platform isEqualToString:@iPhone1,1]) return @iPhone 2G; if ([platform isEqualToString:@iPhone1,2]) return @iPhone 3G; if ([platform isEqualToString:@iPhone2,1]) return @iPhone 3GS; if ([platform isEqualToString:@iPhone3,1]) return @iPhone 4; if ([platform isEqualToString:@iPhone3,2]) return @iPhone 4; if ([platform isEqualToString:@iPhone3,3]) return @iPhone 4; if ([platform isEqualToString:@iPhone4,1]) return @iPhone 4S; if ([platform isEqualToString:@iPhone5,1]) return @iPhone 5; if ([platform isEqualToString:@iPhone5,2]) return @iPhone 5; if ([platform isEqualToString:@iPhone5,3]) return @iPhone 5c; if ([platform isEqualToString:@iPhone5,4]) return @iPhone 5c; if ([platform isEqualToString:@iPhone6,1]) return @iPhone 5s; if ([platform isEqualToString:@iPhone6,2]) return @iPhone 5s; if ([platform isEqualToString:@iPhone7,1]) return @iPhone 6 Plus; if ([platform isEqualToString:@iPhone7,2]) return @iPhone 6; if ([platform isEqualToString:@iPhone8,1]) return @iPhone 6s; if ([platform isEqualToString:@iPhone8,2]) return @iPhone 6s Plus; // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([platform isEqualToString:@iPhone9,1]) return @国行、日版、港行iPhone 7; if ([platform isEqualToString:@iPhone9,2]) return @港行、国行iPhone 7 Plus; if ([platform isEqualToString:@iPhone9,3]) return @美版、台版iPhone 7; if ([platform isEqualToString:@iPhone9,4]) return @美版、台版iPhone 7 Plus; if ([platform isEqualToString:@iPhone8,4]) return @iPhone SE; if ([platform isEqualToString:@iPod1,1]) return @iPod Touch 1G; if ([platform isEqualToString:@iPod2,1]) return @iPod Touch 2G; if ([platform isEqualToString:@iPod3,1]) return @iPod Touch 3G; if ([platform isEqualToString:@iPod4,1]) return @iPod Touch 4G; if ([platform isEqualToString:@iPod5,1]) return @iPod Touch 5G; if ([platform isEqualToString:@iPad1,1]) return @iPad 1G; if ([platform isEqualToString:@iPad2,1]) return @iPad 2; if ([platform isEqualToString:@iPad2,2]) return @iPad 2; if ([platform isEqualToString:@iPad2,3]) return @iPad 2; if ([platform isEqualToString:@iPad2,4]) return @iPad 2; if ([platform isEqualToString:@iPad2,5]) return @iPad Mini 1G; if ([platform isEqualToString:@iPad2,6]) return @iPad Mini 1G; if ([platform isEqualToString:@iPad2,7]) return @iPad Mini 1G; if ([platform isEqualToString:@iPad3,1]) return @iPad 3; if ([platform isEqualToString:@iPad3,2]) return @iPad 3; if ([platform isEqualToString:@iPad3,3]) return @iPad 3; if ([platform isEqualToString:@iPad3,4]) return @iPad 4; if ([platform isEqualToString:@iPad3,5]) return @iPad 4; if ([platform isEqualToString:@iPad3,6]) return @iPad 4; if ([platform isEqualToString:@iPad4,1]) return @iPad Air; if ([platform isEqualToString:@iPad4,2]) return @iPad Air; if ([platform isEqualToString:@iPad4,3]) return @iPad Air; if ([platform isEqualToString:@iPad4,4]) return @iPad Mini 2G; if ([platform isEqualToString:@iPad4,5]) return @iPad Mini 2G; if ([platform isEqualToString:@iPad4,6]) return @iPad Mini 2G; if ([platform isEqualToString:@i386]) return @iPhone Simulator; if ([platform isEqualToString:@x86_64]) return @iPhone Simulator; return platform; } 49、长按复制功能 - (void)viewDidLoad {  [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]]; } - (void)pasteBoard:(UILongPressGestureRecognizer *)longPress {  if (longPress.state == UIGestureRecognizerStateBegan) {  UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];  pasteboard.string = @需要复制的文本;  } } 50、cocoapods升级 在终端执行 sudo gem install -n / usr / local / bin cocoapods –pre 51、设置启动页后，依然显示之前的 删除app，手机重启，重新安装 52、判断图片类型 //通过图片Data数据第一个字节 来获取图片扩展名 - (NSString *)contentTypeForImageData:(NSData *)data {  uint8_t c;  [data getBytes:&amp;c length:1];  switch (c)  {  case 0xFF:   return @jpeg;  case 0x89:   return @png;  case 0x47:   return @gif;  case 0x49:  case 0x4D:   return @tiff;  case 0x52:  if ([data length] &lt; 12) {   return nil;  }  NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];  if ([testString hasPrefix:@RIFF]   &amp;&amp; [testString hasSuffix:@WEBP])  {   return @webp;  }  return nil;  } return nil; } 53、获取手机和app信息  NSDictionary infoDictionary = [[NSBundle mainBundle] infoDictionary]; ​  CFShow(infoDictionary); // app名称 ​  NSString *appName = [infoDictionary objectForKey:@”CFBundleDisplayName”]; // app版本 ​  NSString *app*Version = [infoDictionary objectForKey:@”CFBundleShortVersionString”]; // app build版本 ​  NSString *app_build = [infoDictionary objectForKey:@”CFBundleVersion”]; //手机序列号 ​  NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; ​  NSLog(@”手机序列号: %@”,identifierNumber); //手机别名： 用户定义的名称 ​  NSString* userPhoneName = [[UIDevice currentDevice] name]; ​  NSLog(@”手机别名: %@”, userPhoneName); //设备名称 ​  NSString* deviceName = [[UIDevice currentDevice] systemName]; ​  NSLog(@”设备名称: %@”,deviceName ); //手机系统版本 ​  NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; ​  NSLog(@”手机系统版本: %@”, phoneVersion); //手机型号 ​  NSString* phoneModel = [[UIDevice currentDevice] model]; ​  NSLog(@”手机型号: %@”,phoneModel ); //地方型号 （国际化区域名称） ​  NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; ​  NSLog(@”国际化区域名称: %@”,localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; // 当前应用名称 ​  NSString *appCurName = [infoDictionary objectForKey:@”CFBundleDisplayName”]; ​  NSLog(@”当前应用名称：%@”,appCurName); // 当前应用软件版本 比如：1.0.1 ​  NSString *appCurVersion = [infoDictionary objectForKey:@”CFBundleShortVersionString”]; ​  NSLog(@”当前应用软件版本:%@”,appCurVersion); // 当前应用版本号码 int类型 ​  NSString *appCurVersionNum = [infoDictionary objectForKey:@”CFBundleVersion”]; ​  NSLog(@”当前应用版本号码：%@”,appCurVersionNum); 54、获取一个类的所有属性 id LenderClass = objc_getClass(Lender); unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount); for (i = 0; i &lt; outCount; i++) {  objc_property_t property = properties[i];  fprintf(stdout, %s %s  , property_getName(property), property_getAttributes(property)); } 55、image圆角 - (UIImage *)circleImage{  // NO代表透明  UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);  // 获得上下文  CGContextRef ctx = UIGraphicsGetCurrentContext();  // 添加一个圆  CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);  // 方形变圆形  CGContextAddEllipseInRect(ctx, rect);  // 裁剪  CGContextClip(ctx);  // 将图片画上去  [self drawInRect:rect];  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext();  return image; } 56、image拉伸 + (UIImage *)resizableImage:(NSString *)imageName {  UIImage *image = [UIImage imageNamed:imageName];  CGFloat imageW = image.size.width;  CGFloat imageH = image.size.height;  return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch]; } 57、JSON字符串转字典 + (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {  NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];  NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];  return responseJSON; } 58、身份证号验证 - (BOOL)validateIdentityCard {  BOOL flag;  if (self.length &lt;= 0) {  flag = NO;  return flag;  }  NSString *regex2 = @^(    d{14}|    d{17})(    d|[xX])$;  NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@SELF MATCHES %@,regex2];  return [identityCardPredicate evaluateWithObject:self]; } 59、获取设备mac地址 + (NSString *)macAddress {  int    mib[6];  size_t   len;  char   *buf;  unsigned char  *ptr;  struct if_msghdr *ifm;  struct sockaddr_dl *sdl; mib[0] = CTL_NET;  mib[1] = AF_ROUTE;  mib[2] = 0;  mib[3] = AF_LINK;  mib[4] = NET_RT_IFLIST; if((mib[5] = if_nametoindex(en0)) == 0) {  printf(Error: if_nametoindex error  );  return NULL;  } if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) {  printf(Error: sysctl, take 1  );  return NULL;  } if((buf = malloc(len)) == NULL) {  printf(Could not allocate memory. Rrror!  );  return NULL;  } if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) {  printf(Error: sysctl, take 2);  return NULL;  } ifm = (struct if_msghdr *)buf;  sdl = (struct sockaddr_dl *)(ifm + 1);  ptr = (unsigned char *)LLADDR(sdl);  NSString *outstring = [NSString stringWithFormat:@X:X:X:X:X:X,     *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];  free(buf); return outstring; } 60、导入自定义字体库  1、找到你想用的字体的 ttf 格式，拖入工程 2、在工程的plist中增加一行数组，“Fonts provided by application” 3、为这个key添加一个item，value为你刚才导入的ttf文件名 4、直接使用即可：label.font = [UIFont fontWithName:@”你刚才导入的ttf文件名” size:20.0]； 61、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到 - (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {  if ([vc isKindOfClass:[UINavigationController class]]) {  return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];  }else if ([vc isKindOfClass:[UITabBarController class]]){  return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];  } else {  if (vc.presentedViewController) {   return [self getVisibleViewControllerFrom:vc.presentedViewController];  } else {   return vc;  }  } } 62、runtime为一个类动态添加属性 // 动态添加属性的本质是: 让对象的某个属性与值产生关联  objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 63、获取runtime为一个类动态添加的属性 objc_getAssociatedObject(self, WZBPlaceholderViewKey); 64、KVO监听某个对象的属性 // 添加监听者 [self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil]; // 当监听的属性值变化的时候会来到这个方法 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {  if ([keyPath isEqualToString:@property]) {  [self textViewTextChange];  } else { } } 65、Reachability判断网络状态 NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];  if (status == NotReachable) {  NSLog(@当前设备无网络);  }  if (status == ReachableViaWiFi) {  NSLog(@当前wifi网络);  }  if (status == NotReachable) {  NSLog(@当前蜂窝移动网络);  } 66、AFNetworking监听网络状态 // 监听网络状况  AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];  [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {  switch (status) {   case AFNetworkReachabilityStatusUnknown:    break;   case AFNetworkReachabilityStatusNotReachable: {    [SVProgressHUD showInfoWithStatus:@当前设备无网络];   }    break;   case AFNetworkReachabilityStatusReachableViaWiFi:    [SVProgressHUD showInfoWithStatus:@当前Wi-Fi网络];    break;   case AFNetworkReachabilityStatusReachableViaWWAN:    [SVProgressHUD showInfoWithStatus:@当前蜂窝移动网络];    break;   default:    break;  }  }];  [mgr startMonitoring]; 67、透明颜色不影响子视图透明度 [UIColor colorWithRed: green: blue: alpha:]; 68、取图片某一点的颜色 if (point.x &lt; 0 || point.y &lt; 0) return nil; CGImageRef imageRef = self.CGImage; NSUInteger width = CGImageGetWidth(imageRef); NSUInteger height = CGImageGetHeight(imageRef); if (point.x &gt;= width || point.y &gt;= height) return nil; unsigned char *rawData = malloc(height * width * 4); if (!rawData) return nil; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData,        width,        height,        bitsPerComponent,        bytesPerRow,        colorSpace,        kCGImageAlphaPremultipliedLast        | kCGBitmapByteOrder32Big); if (!context) {  free(rawData);  return nil; } CGColorSpaceRelease(colorSpace); CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGContextRelease(context); int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel; CGFloat red = (rawData[byteIndex]  * 1.0) / 255.0; CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0; CGFloat blue = (rawData[byteIndex + 2] * 1.0) / 255.0; CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0; UIColor *result = nil; result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; free(rawData); return result; 69、判断该图片是否有透明度通道 - (BOOL)hasAlphaChannel {  CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);  return (alpha == kCGImageAlphaFirst ||   alpha == kCGImageAlphaLast ||   alpha == kCGImageAlphaPremultipliedFirst ||   alpha == kCGImageAlphaPremultipliedLast); } 70、获得灰度图 + (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage {  int width = sourceImage.size.width;  int height = sourceImage.size.height; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();  CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);  CGColorSpaceRelease(colorSpace); if (context == NULL) {  return nil;  } CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);  CGImageRef contextRef = CGBitmapContextCreateImage(context);  UIImage *grayImage = [UIImage imageWithCGImage:contextRef];  CGContextRelease(context);  CGImageRelease(contextRef); return grayImage; } 71、根据bundle中的文件名读取图片  + (UIImage *)imageWithFileName:(NSString *)name {  NSString *extension = @png; NSArray *components = [name componentsSeparatedByString:@.];  if ([components count] &gt;= 2) {  NSUInteger lastIndex = components.count - 1;  extension = [components objectAtIndex:lastIndex];  name = [name substringToIndex:(name.length-(extension.length+1))];  } // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片  if ([UIScreen mainScreen].scale == 2.0) {  name = [name stringByAppendingString:@@2x];  NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];  if (path != nil) {   return [UIImage imageWithContentsOfFile:path];  }  } if ([UIScreen mainScreen].scale == 3.0) {  name = [name stringByAppendingString:@@3x];  NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];  if (path != nil) {   return [UIImage imageWithContentsOfFile:path];  }  } NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];  if (path) {  return [UIImage imageWithContentsOfFile:path];  } return nil; } 72、合并两个图片 + (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage {  CGImageRef firstImageRef = firstImage.CGImage;  CGFloat firstWidth = CGImageGetWidth(firstImageRef);  CGFloat firstHeight = CGImageGetHeight(firstImageRef);  CGImageRef secondImageRef = secondImage.CGImage;  CGFloat secondWidth = CGImageGetWidth(secondImageRef);  CGFloat secondHeight = CGImageGetHeight(secondImageRef);  CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight));  UIGraphicsBeginImageContext(mergedSize);  [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)];  [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)];  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext();  return image; } 73、根据bundle中的图片名创建imageview + (id)imageViewWithImageNamed:(NSString*)imageName {  return [[UIImageView alloc] initWithImage:[UIImage imageNamed:imageName]]; } 74、为imageView添加倒影 CGRect frame = self.frame; frame.origin.y += (frame.size.height + 1); UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame]; self.clipsToBounds = TRUE; reflectionImageView.contentMode = self.contentMode; [reflectionImageView setImage:self.image]; reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0); CALayer *reflectionLayer = [reflectionImageView layer]; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.bounds = reflectionLayer.bounds; gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5); gradientLayer.colors = [NSArray arrayWithObjects:     (id)[[UIColor clearColor] CGColor],     (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil]; gradientLayer.startPoint = CGPointMake(0.5,0.5); gradientLayer.endPoint = CGPointMake(0.5,1.0); reflectionLayer.mask = gradientLayer; [self.superview addSubview:reflectionImageView]; 75、画水印 // 画水印 - (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect {  if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0)  {  UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);  }  //原图  [image drawInRect:self.bounds];  //水印图  [mark drawInRect:rect];  UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext();  self.image = newPic; } 76、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部 自定义UILabel // 重写label的textRectForBounds方法 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {  CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];  switch (self.textAlignmentType) {  case WZBTextAlignmentTypeLeftTop: {   rect.origin = bounds.origin;  }   break;  case WZBTextAlignmentTypeRightTop: {   rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y);  }   break;  case WZBTextAlignmentTypeLeftBottom: {   rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height);  }   break;  case WZBTextAlignmentTypeRightBottom: {   rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height);  }   break;  case WZBTextAlignmentTypeTopCenter: {   rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y);  }   break;  case WZBTextAlignmentTypeBottomCenter: {   rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height);  }   break;  case WZBTextAlignmentTypeLeft: {   rect.origin = CGPointMake(0, rect.origin.y);  }   break;  case WZBTextAlignmentTypeRight: {   rect.origin = CGPointMake(rect.origin.x, 0);  }   break;  case WZBTextAlignmentTypeCenter: {   rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2);  }   break;  default:   break;  }  return rect; } - (void)drawTextInRect:(CGRect)rect {  CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines];  [super drawTextInRect:textRect]; } 77、scrollView上的输入框，键盘挡住的问题 推荐用IQKeyboardManager这个框架！手动解决如下  1、监听键盘弹出／消失的通知2、在通知中加入代码：  NSDictionary* info = [aNotification userInfo];  CGRect keyPadFrame=[[UIApplication sharedApplication].keyWindow convertRect:[[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue] fromView:self.view];  CGSize kbSize =keyPadFrame.size;  CGRect activeRect=[self.view convertRect:activeField.frame fromView:activeField.superview];  CGRect aRect = self.view.bounds;  aRect.size.height -= (kbSize.height); CGPoint origin = activeRect.origin;  origin.y -= backScrollView.contentOffset.y;  if (!CGRectContainsPoint(aRect, origin)) {  CGPoint scrollPoint = CGPointMake(0.0,CGRectGetMaxY(activeRect)-(aRect.size.height));  [backScrollView setContentOffset:scrollPoint animated:YES];  } 78、frame布局的cell动态高度 这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。 79、AutoLayout布局的cell动态高度  // 1、设置tableView的属性  self.tableView.rowHeight = UITableViewAutomaticDimension;  self.tableView.estimatedRowHeight = 44.0; // 这个属性非0，估计cell高度 // 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周  80、使用performSelector:调用函数，内存泄漏问题 当我们在开发中使用[obj performSelector:NSSelectorFromString(@”aMethod”)];这类方法时可能会收到一个警告”performSelector may cause a leak because its selector is unknown”. 是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！  使用以下代码调用即可： if (! obj) { return; } SEL selector = NSSelectorFromString(@aMethod); IMP imp = [obj methodForSelector:selector]; void (*func)(id, SEL) = (void *)imp; func(obj, selector); 或者： SEL selector = NSSelectorFromString(@aMethod); ((void (*)(id, SEL))[obj methodForSelector:selector])(obj, selector); 81、一个字符串是否包含另一个字符串 // 方法1 if ([str1 containsString:str2]) {  NSLog(@str1包含str2);  } else {  NSLog(@str1不包含str2);  } // 方法2 if ([str1 rangeOfString: str2].location == NSNotFound) {  NSLog(@str1包含str2);  } else {  NSLog(@str1不包含str2);  } 82、cell去除选中效果 cell.selectionStyle = UITableViewCellSelectionStyleNone; 83、cell点按效果 - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {  [tableView deselectRowAtIndexPath:indexPath animated:YES]; } 84、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash  点击这个叉号删除 85、真机测试的时候报错：Could not launch “你的 App”，process launch failed: Security 因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置-&gt;通用-&gt;描述文件-&gt;点击你的app的描述文件-&gt;点击信任 86、真机测试的时候报错：Could not find Developer Disk Image 这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！ 87、UITextView没有placeholder的问题？ 网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 UITextView-WZB 88、移除字符串中的空格和换行 + (NSString *)removeSpaceAndNewline:(NSString *)str {  NSString *temp = [str stringByReplacingOccurrencesOfString:@ withString:@];  temp = [temp stringByReplacingOccurrencesOfString:@  r withString:@];  temp = [temp stringByReplacingOccurrencesOfString:@  withString:@];  return temp; } 89、判断字符串中是否有空格 + (BOOL)isBlank:(NSString *)str {  NSRange _range = [str rangeOfString:@ ];  if (_range.location != NSNotFound) {  //有空格  return YES;  } else {  //没有空格  return NO;  } } 90、获取一个视频的第一帧图片 NSURL *url = [NSURL URLWithString:filepath]; AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1]; generate1.appliesPreferredTrackTransform = YES; NSError *err = NULL; CMTime time = CMTimeMake(1, 2); CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err]; UIImage *one = [[UIImage alloc] initWithCGImage:oneRef]; return one; 91、获取视频的时长 + (NSInteger)getVideoTimeByUrlString:(NSString *)urlString {  NSURL *videoUrl = [NSURL URLWithString:urlString];  AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl];  CMTime time = [avUrl duration];  int seconds = ceil(time.value/time.timescale);  return seconds; } 92、字符串是否为空 + (BOOL)isEqualToNil:(NSString *)str {  return str.length &lt;= 0 || [str isEqualToString:@] || !str; } 93、将app上传到App Store的时候通常会遇到这个问题  try again 很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！ 但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。 如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。 94、当tableView占不满一屏时，去除下边多余的单元格 self.tableView.tableHeaderView = [UIView new]; self.tableView.tableFooterView = [UIView new]; 95、isKindOfClass和isMemberOfClass的区别  isKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。isMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类) 96、__block 当一个局部变量需要在block里改变时，需要在定义时加上_block修饰，具体请看官方文档 http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html #//appleref/doc/uid/TP40007502-CH6-SW6 97、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0 这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法 98、UITableView () failed to obtain a cell from its dataSource () 这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃 99、约束如何做UIView动画？  1、把需要改的约束Constraint拖条线出来，成为属性 2、在需要动画的地方加入代码，改变此属性的constant属性 3、开始做UIView动画，动画里边调用layoutIfNeeded方法 @property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint; self.buttonTopConstraint.constant = 100;  [UIView animateWithDuration:.5 animations:^{  [self.view layoutIfNeeded];  }]; 100、从NSURL中拿到链接字符串 NSString *urlString = myURL.absoluteString; 101、将tableView滚动到顶部 [tableView setContentOffset:CGPointZero animated:YES]; 或者 [tableView scrollRectToVisible:CGRectMake(0, 0, 1, 1) animated:YES]; 102、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码 [youButton removeTarget:nil action:nil forControlEvents:UIControlEventAllEvents]; 103、某个字体的高度 font.lineHeight; 104、删除某个view所有的子视图 [[someView subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)]; 105、删除NSUserDefaults所有记录 //方法一 NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  //方法二 - (void)resetDefaults { NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) {   [defs removeObjectForKey:key]; }  [defs synchronize]; } // 方法三 [[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; 106、禁用系统滑动返回功能 - (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self;  } } - (void)viewWillDisappear:(BOOL)animated {  [super viewWillDisappear:animated];  if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil;  } } - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer { return NO; } 107、模拟器报错  模拟器报错 解决办法： 打开模拟器-&gt;Simulator-&gt;Reset Content and Settings… 如果不行，就重启试试！ 108、自定义cell选中背景颜色 UIView *bgColorView = [[UIView alloc] init]; bgColorView.backgroundColor = [UIColor redColor]; [cell setSelectedBackgroundView:bgColorView]; 109、UILabel设置内边距 子类化UILabel，重写drawTextInRect方法 - (void)drawTextInRect:(CGRect)rect {  // 边距，上左下右  UIEdgeInsets insets = {0, 5, 0, 5};  [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)]; } 110、UILabel设置文字描边 子类化UILabel，重写drawTextInRect方法 - (void)drawTextInRect:(CGRect)rect{  CGContextRef c = UIGraphicsGetCurrentContext();  // 设置描边宽度  CGContextSetLineWidth(c, 1);  CGContextSetLineJoin(c, kCGLineJoinRound);  CGContextSetTextDrawingMode(c, kCGTextStroke);  // 描边颜色  self.textColor = [UIColor redColor];  [super drawTextInRect:rect];  // 文本颜色  self.textColor = [UIColor yellowColor];  CGContextSetTextDrawingMode(c, kCGTextFill);  [super drawTextInRect:rect]; } 111、使用模拟器截图 快捷键command + s 或者File-&gt;Save Screen Shot 112、scrollView滚动到最下边 CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height); [scrollView setContentOffset:bottomOffset animated:YES]; 113、UIView背景颜色渐变 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)]; [self.view addSubview:view]; CAGradientLayer *gradient = [CAGradientLayer layer]; gradient.frame = view.bounds; gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil]; [view.layer insertSublayer:gradient atIndex:0]; 114、停止UIView动画 [yourView.layer removeAllAnimations] 115、为UIView某个角添加圆角 // 左上角和右下角添加圆角 UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];  CAShapeLayer *maskLayer = [CAShapeLayer layer];  maskLayer.frame = view.bounds;  maskLayer.path = maskPath.CGPath;  view.layer.mask = maskLayer; 116、删除Xcode Derived data缓存数据 依次点击Xcode -&gt; Preferences -&gt; location，然后点击 Derived data路径后到小箭头，删除这个文件夹下的数据就可以了，如图  Xcode Derived data 117、将一个view放置在其兄弟视图的最上面 [parentView bringSubviewToFront:yourView] 118、将一个view放置在其兄弟视图的最下面 [parentView sendSubviewToBack:yourView] 119、让手机震动一下 倒入框架 #import AudioServicesPlayAlertSound(kSystemSoundIDVibrate); 或者 AudioServicesPlaySystemSound(kSystemSoundIDVibrate); 120、layoutSubviews方法什么时候调用？  1、init方法不会调用 2、addSubview方法等时候会调用 3、bounds改变的时候调用 4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑) 5、旋转设备的时候调用 6、子视图被移除的时候调用 参考请看：http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/ 121、让UILabel在指定的地方换行 // 换行符为  ,在需要换行的地方加上这个符号即可，如 label.numberOfLines = 0; label.text = @此处  换行; 122、摇一摇功能  1、打开摇一摇功能 [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES; 2、让需要摇动的控制器成为第一响应者 [self becomeFirstResponder]; 3、实现以下方法 // 开始摇动 - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event // 取消摇动 - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event // 摇动结束 - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 123、获取图片大小 CGFloat imageWidth = image.size.width; CGFloat imageHeight = imageWidth * image.scale; 124、获取view的坐标在整个window上的位置 // v上的(0, 0)点在toView上的位置 CGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject]; 或者 CGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject]; 125、提交App Store审核程序限制 您的应用程序的未压缩大小必须小于4GB。每个Mach-O可执行文件（例如appname.app/appname）不能超过这些限制：对于MinimumOSVersion小于7.0的应用程序：TEXT二进制文件中所有部分的总数最多为80 MB 。对于MinimumOSVersion7.x到8.x的应用程序：TEXT对于二进制文件中每个体系结构片段的每个片段，最大为60 MB 。对于MinimumOSVersion9.0或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为500 MB 。参阅：iTunes Connect开发者指南 126、修改UISegmentedControl的字体大小 [segment setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:15.0f]} forState:UIControlStateNormal]; 127、在非ViewController的地方弹出UIAlertController对话框 // 最好抽成一个分类 UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@Title message:@message preferredStyle:UIAlertControllerStyleAlert]; //... id rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController; if([rootViewController isKindOfClass:[UINavigationController class]]) {  rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject; } if([rootViewController isKindOfClass:[UITabBarController class]]) {  rootViewController = ((UITabBarController *)rootViewController).selectedViewController; } [rootViewController presentViewController:alertController animated:YES completion:nil]; 128、获取一个view所属的控制器 // view分类方法 - (UIViewController *)belongViewController {  for (UIView *next = [self superview]; next; next = next.superview) {  UIResponder* nextResponder = [next nextResponder];  if ([nextResponder isKindOfClass:[UIViewController class]]) {   return (UIViewController *)nextResponder;  }  }  return nil; } 129、UIImage和base64互转 // view分类方法 - (NSString *)encodeToBase64String:(UIImage *)image { return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } - (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData { NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [UIImage imageWithData:data]; } 130、UIWebView设置背景透明 [webView setBackgroundColor:[UIColor clearColor]]; [webView setOpaque:NO]; 131、判断NSDate是不是今天 NSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate]; NSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]]; if([today day] == [otherDay day] &amp;&amp; [today month] == [otherDay month] &amp;&amp; [today year] == [otherDay year] &amp;&amp; [today era] == [otherDay era]) {  // 是今天 } 132、设置tableView分割线颜色 [self.tableView setSeparatorColor:[UIColor myColor]]; 133、设置屏幕方向 [[UIDevice currentDevice] setValue:@(UIInterfaceOrientationLandscapeLeft) forKey:@orientation]; 134、比较两个颜色是否相等 - (BOOL)isEqualToColor:(UIColor *)otherColor {  CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB(); 6  UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {  if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {   const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);   CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};   CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components ); 6   UIColor *color = [UIColor colorWithCGColor:colorRef];   CGColorRelease(colorRef);   return color;    } else   return color;  }; 6  UIColor *selfColor = convertColorToRGBSpace(self);  otherColor = convertColorToRGBSpace(otherColor);  CGColorSpaceRelease(colorSpaceRGB);  return [selfColor isEqual:otherColor]; } 135、tableViewCell分割线顶到头 - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {  [cell setSeparatorInset:UIEdgeInsetsZero];  [cell setLayoutMargins:UIEdgeInsetsZero];  cell.preservesSuperviewLayoutMargins = NO; } - (void)viewDidLayoutSubviews {  [self.tableView setSeparatorInset:UIEdgeInsetsZero];  [self.tableView setLayoutMargins:UIEdgeInsetsZero]; } 136、不让控制器的view随着控制器的xib拉伸或压缩 self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; 137、cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1. You can try adding it manually in ~/.cocoapods/repos or via pod repo add. 解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了 在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可 138、安装cocoapods的时候出现 ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/pod 解决办法：直接在终端执行 sudo gem install -n /usr/local/bin cocoapods 139、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花 [UIApplication sharedApplication].networkActivityIndicatorVisible = YES; 140、检查一个rect是否包含一个point // point是否在rect内 BOOL isContains = CGRectContainsPoint(rect, point); 141、在指定的宽度下，让UILabel自动设置最佳font label.adjustsFontSizeToFitWidth = YES; 142、将一个image保存在相册中 UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil); 或者 #import [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{  PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];  changeRequest.creationDate  = [NSDate date];  } completionHandler:^(BOOL success, NSError *error) {  if (success) {   NSLog(@successfully saved);  }  else {   NSLog(@error saving to photos: %@, error);  }  }]; 143、修改cell.imageView的大小 UIImage *icon = [UIImage imageNamed:@]; CGSize itemSize = CGSizeMake(30, 30); UIGraphicsBeginImageContextWithOptions(itemSize, NO ,0.0); CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height); [icon drawInRect:imageRect]; cell.imageView.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); 144、为一个view添加虚线边框 CAShapeLayer *border = [CAShapeLayer layer];  border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;  border.fillColor = nil;  border.lineDashPattern = @[@4, @2];  border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;  border.frame = view.bounds;  [view.layer addSublayer:border]; 145、UITextView中打开或禁用复制，剪切，选择，全选等功能 // 继承UITextView重写这个方法 - (BOOL)canPerformAction:(SEL)action withSender:(id)sender { // 返回NO为禁用，YES为开启  // 粘贴  if (action == @selector(paste:)) return NO;  // 剪切  if (action == @selector(cut:)) return NO;  // 复制  if (action == @selector(copy:)) return NO;  // 选择  if (action == @selector(select:)) return NO;  // 选中全部  if (action == @selector(selectAll:)) return NO;  // 删除  if (action == @selector(delete:)) return NO;  // 分享  if (action == @selector(share)) return NO;  return [super canPerformAction:action withSender:sender]; ",
      "url"      : "http://localhost:4000/2017/06/27/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7(%E4%B8%80)/"
    } ,
  
    {
      "title"    : "Ios开发技巧(二)",
      "category" : "",
      "content": " iOS开发技巧(二) 作者:AustinKuture 1、设置UILabel行间距 NSMutableAttributedString* attrString = [[NSMutableAttributedString alloc] initWithString:label.text]; NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; [style setLineSpacing:20]; [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)]; label.attributedText = attrString; 或者使用xib，看下gif图  2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题  方法一、把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典 NSArray * array = [NSArray arrayWithObjects: @first, @second, nil]; [self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0]; 方法二、使用NSInvocation  SEL aSelector = NSSelectorFromString(@doSoming:argument2:);  NSInteger argument1 = 10;  NSString *argument2 = @argument2;  if([self respondsToSelector:aSelector]) {   NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];   [inv setSelector:aSelector];   [inv setTarget:self];   [inv setArgument:&amp;(argument1) atIndex:2];   [inv setArgument:&amp;(argument2) atIndex:3];   [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];  } 3、UILabel显示不同颜色字体 NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)]; label.attributedText = string; 4、比较两个CGRect/CGSize/CGPoint是否相等 if (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等  // do some  }  if (CGPointEqualToPoint(point1, point2)) { // 两个点相等  // do some  }  if (CGSizeEqualToSize(size1, size2)) { // 两个size相等  // do some  } 5、比较两个NSDate相差多少小时 NSDate* date1 = someDate; NSDate* date2 = someOtherDate; NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2]; double secondsInAnHour = 3600; // 除以3600是把秒化成小时，除以60得到结果为相差的分钟数 NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour; 6、每个cell之间增加间距  方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row) - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {  return yourArry.count; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {  return 1; } -(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section {  return cellSpacingHeight; } 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。 方法三，自定义cell，重写setFrame：方法 - (void)setFrame:(CGRect)frame{ frame.size.height -= 20;  [super setFrame:frame]; } 7、播放一张张连续的图片  加入现在有三张图片分别为animate1、animate2、animate_3方法一  imageView.animationImages = @[[UIImage imageNamed:@animate_1], [UIImage imageNamed:@animate_2], [UIImage imageNamed:@animate_3]]; imageView.animationDuration = 1.0; 方法二 imageView.image = [UIImage animatedImageNamed:@animate_ duration:1.0]; 方法二解释下，这个方法会加载animate为前缀的，后边0-1024，也就是animate0、animate1一直到animate1024 8、加载gif图片 推荐使用这个框架 FLAnimatedImage 9、防止离屏渲染为image添加圆角  image分类 - (UIImage *)circleImage { // NO代表透明 UIGraphicsBeginImageContextWithOptions(self.size, NO, 1); // 获得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 添加一个圆 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); // 方形变圆形 CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将图片画上去 [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 10、查看系统所有字体  打印字体 for (id familyName in [UIFont familyNames]) {  NSLog(@%@, familyName);  for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@ %@, fontName); } 也可以进入这个网址查看 http://iosfonts.com/ 11、获取随机数 NSInteger i = arc4random(); 12、获取随机数小数(0-1之间) #define ARC4RANDOM_MAX 0x100000000 double val = ((double)arc4random() / ARC4RANDOM_MAX); 13、AVPlayer视频播放完成的通知监听 [[NSNotificationCenter defaultCenter]  addObserver:self  selector:@selector(videoPlayEnd)  name:AVPlayerItemDidPlayToEndTimeNotification  object:nil]; 14、判断两个rect是否有交叉 if (CGRectIntersectsRect(rect1, rect2)) { } 15、判断一个字符串是否为数字 NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];  if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)  {  // 是数字  } else  {  // 不是数字  } 16、将一个view保存为pdf格式 - (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename {  NSMutableData *pdfData = [NSMutableData data];  UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);  UIGraphicsBeginPDFPage();  CGContextRef pdfContext = UIGraphicsGetCurrentContext();  [aView.layer renderInContext:pdfContext];  UIGraphicsEndPDFContext(); NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);  NSString* documentDirectory = [documentDirectories objectAtIndex:0];  NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];  [pdfData writeToFile:documentDirectoryFilename atomically:YES];  NSLog(@documentDirectoryFileName: %@,documentDirectoryFilename); } 17、让一个view在父视图中心 child.center = [parent convertPoint:parent.center fromView:parent.superview]; 18、获取当前导航控制器下前一个控制器 - (UIViewController *)backViewController {  NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self]; if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) {  return [self.navigationController.viewControllers objectAtIndex:myIndex-1];  } else {  return nil;  } } 19、保存UIImage到本地 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@Image.png]; [UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES]; 20、键盘上方增加工具栏 UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init]; [keyboardDoneButtonView sizeToFit]; UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@Done           style:UIBarButtonItemStyleBordered target:self           action:@selector(doneClicked:)]; [keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]]; txtField.inputAccessoryView = keyboardDoneButtonView; 21、copy一个view 因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃 但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下 id copyOfView = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]]; 22、在image上绘制文字并生成新的image UIFont *font = [UIFont boldSystemFontOfSize:12];  UIGraphicsBeginImageContext(image.size);  [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];  CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);  [[UIColor whiteColor] set];  [text drawInRect:CGRectIntegral(rect) withFont:font]; UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext(); 23、判断一个view是否为另一个view的子视图  如果myView是self.view本身，也会返回yes BOOL isSubView = [myView isDescendantOfView:self.view]; 24、判断一个字符串是否包含另一个字符串  方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二 if ([str containsString:otherStr]) NSLog(@包含); 方法二 NSRange range = [str rangeOfString:otherStr]; if (range.location != NSNotFound) NSLog(@包含); 25、UICollectionView自动滚动到某行 重写viewDidLayoutSubviews方法 -(void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO]; } 26、修改系统UIAlertController  但是据说这种方法会被App Store拒绝(慎用！) UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@ message:@ preferredStyle:UIAlertControllerStyleActionSheet];  NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@我是一个大文本];  [hogan addAttribute:NSFontAttributeName    value:[UIFont systemFontOfSize:30]    range:NSMakeRange(4, 1)];  [hogan addAttribute:NSForegroundColorAttributeName    value:[UIColor redColor]    range:NSMakeRange(4, 1)];  [alertVC setValue:hogan forKey:@attributedTitle]; UIAlertAction *button = [UIAlertAction actionWithTitle:@Label text style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];  UIImage *accessoryImage = [UIImage imageNamed:@1];  [button setValue:accessoryImage forKey:@image];  [alertVC addAction:button];  [self presentViewController:alertVC animated:YES completion:nil]; 27、判断某一行的cell是否已经显示 CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath]; BOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect); 28、让导航控制器pop回指定的控制器 NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]]; for (UIViewController *aViewController in allViewControllers) {  if ([aViewController isKindOfClass:[RequiredViewController class]]) {  [self.navigationController popToViewController:aViewController animated:NO];  } } 29、动画修改label上的文字  方法一 CATransition *animation = [CATransition animation];  animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];  animation.type = kCATransitionFade;  animation.duration = 0.75;  [self.label.layer addAnimation:animation forKey:@kCATransitionFade];  self.label.text = @New; 方法二 [UIView transitionWithView:self.label     duration:0.25f    options:UIViewAnimationOptionTransitionCrossDissolve    animations:^{     self.label.text = @Well done!;    } completion:nil]; 方法三 [UIView animateWithDuration:1.0    animations:^{     self.label.alpha = 0.0f;     self.label.text = @newText;     self.label.alpha = 1.0f;    }]; 30、判断字典中是否包含某个key值 if ([dic objectForKey:@yourKey]) {  NSLog(@有这个值); } else {  NSLog(@没有这个值); } 31、获取屏幕方向 UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation; if(orientation == 0) //Default orientation //默认 else if(orientation == UIInterfaceOrientationPortrait)  //竖屏 else if(orientation == UIInterfaceOrientationLandscapeLeft)  // 左横屏 else if(orientation == UIInterfaceOrientationLandscapeRight)  //右横屏 32、设置UIImage的透明度  方法一、添加UIImage分类 - (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {  UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f); CGContextRef ctx = UIGraphicsGetCurrentContext();  CGRect area = CGRectMake(0, 0, self.size.width, self.size.height); CGContextScaleCTM(ctx, 1, -1);  CGContextTranslateCTM(ctx, 0, -area.size.height); CGContextSetBlendMode(ctx, kCGBlendModeMultiply); CGContextSetAlpha(ctx, alpha); CGContextDrawImage(ctx, area, self.CGImage); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度 UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@yourImage]]; imageView.alpha = 0.5; 33、Attempt to mutate immutable object with insertString:atIndex: 这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用 34、UIWebView添加单击手势不响应 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];  tap.delegate = self;  [_webView addGestureRecognizer:tap]; 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{  return YES; } 35、获取手机RAM容量  需要导入#import mach_port_t host_port;  mach_msg_type_number_t host_size;  vm_size_t pagesize; host_port = mach_host_self();  host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);  host_page_size(host_port, &amp;pagesize); vm_statistics_data_t vm_stat; if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) {  NSLog(@Failed to fetch vm statistics);  } /* Stats in bytes */  natural_t mem_used = (vm_stat.active_count +     vm_stat.inactive_count +     vm_stat.wire_count) * pagesize;  natural_t mem_free = vm_stat.free_count * pagesize;  natural_t mem_total = mem_used + mem_free;  NSLog(@已用: %u 可用: %u 总共: %u, mem_used, mem_free, mem_total); 36、地图上两个点之间的实际距离  需要导入#import CLLocation *locA = [[CLLocation alloc] initWithLatitude:34 longitude:113];  CLLocation *locB = [[CLLocation alloc] initWithLatitude:31.05 longitude:121.76]; // CLLocationDistance求出的单位为米  CLLocationDistance distance = [locA distanceFromLocation:locB]; 37、在应用中打开设置的某个界面  打开设置-&gt;通用 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@prefs:root=General]]; 以下是设置其他界面 prefs:root=General&amp;path=About prefs:root=General&amp;path=ACCESSIBILITY prefs:root=AIRPLANE_MODE prefs:root=General&amp;path=AUTOLOCK prefs:root=General&amp;path=USAGE/CELLULAR_USAGE prefs:root=Brightness prefs:root=Bluetooth prefs:root=General&amp;path=DATE_AND_TIME prefs:root=FACETIME prefs:root=General prefs:root=General&amp;path=Keyboard prefs:root=CASTLE prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP prefs:root=General&amp;path=INTERNATIONAL prefs:root=LOCATION_SERVICES prefs:root=ACCOUNT_SETTINGS prefs:root=MUSIC prefs:root=MUSIC&amp;path=EQ prefs:root=MUSIC&amp;path=VolumeLimit prefs:root=General&amp;path=Network prefs:root=NIKE_PLUS_IPOD prefs:root=NOTES prefs:root=NOTIFICATIONS_ID prefs:root=Phone prefs:root=Photos prefs:root=General&amp;path=ManagedConfigurationList prefs:root=General&amp;path=Reset prefs:root=Sounds&amp;path=Ringtone prefs:root=Safari prefs:root=General&amp;path=Assistant prefs:root=Sounds prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK prefs:root=STORE prefs:root=TWITTER prefs:root=FACEBOOK prefs:root=General&amp;path=USAGE prefs:root=VIDEO prefs:root=General&amp;path=Network/VPN prefs:root=Wallpaper prefs:root=WIFI prefs:root=INTERNET_TETHERING prefs:root=Phone&amp;path=Blocked prefs:root=DO_NOT_DISTURB 38、在UITextView中显示html文本 UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 30, 100, 199)]; textView.backgroundColor = [UIColor redColor]; [self.view addSubview:textView]; NSString *htmlString = @ NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options: @{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes: nil error: nil]; textView.attributedText = attributedString; 39、监听scrollView是否滚动到了顶部／底部 -(void)scrollViewDidScroll: (UIScrollView*)scrollView { float scrollViewHeight = scrollView.frame.size.height; float scrollContentSizeHeight = scrollView.contentSize.height; float scrollOffset = scrollView.contentOffset.y; if (scrollOffset == 0) {  // 滚动到了顶部 } else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight) {  // 滚动到了底部 } } 40、UISlider增量／减量为固定值(假如为5) - (void)setupSlider {  UISlider *slider = [[UISlider alloc] init];  [self.view addSubview:slider];  [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged];  slider.maximumValue = 100;  slider.minimumValue = 0;  slider.frame = CGRectMake(200, 20, 100, 30); } - (void)sliderAction:(UISlider *)slider {  [slider setValue:((int)((slider.value + 2.5) / 5) * 5) animated:NO]; } 41、选中textField或者textView所有文本(我这里以textView为例) [self.textView setSelectedTextRange:[self.textView textRangeFromPosition:self.textView.beginningOfDocument toPosition:self.textView.endOfDocument]] 42、从导航控制器中删除某个控制器  方法一、知道这个控制器所处的导航控制器下标 NSMutableArray *navigationArray = [[NSMutableArray alloc] initWithArray: self.navigationController.viewControllers]; [navigationArray removeObjectAtIndex: 2]; self.navigationController.viewControllers = navigationArray; 方法二、知道具体是哪个控制器 NSArray* tempVCA = [self.navigationController viewControllers]; for(UIViewController *tempVC in tempVCA) {  if([tempVC isKindOfClass:[urViewControllerClass class]])  {  [tempVC removeFromParentViewController];  } } 43、隐藏UITextView/UITextField光标 textField.tintColor = [UIColor clearColor]; 44、当UITextView/UITextField中没有文字时，禁用回车键 textField.enablesReturnKeyAutomatically = YES; 45、字符串encode编码(编码url字符串不成功的问题)  我们一般用这个方法处理stringByAddingPercentEscapesUsingEncoding但是这个方法好想不会处理／和&amp;这种特殊符号，这种情况就需要用下边这个方法处理 @implementation NSString (NSString_Extended) - (NSString *)urlencode {  NSMutableString *output = [NSMutableString string];  const unsigned char *source = (const unsigned char *)[self UTF8String];  int sourceLen = strlen((const char *)source);  for (int i = 0; i &lt; sourceLen; ++i) {  const unsigned char thisChar = source[i];  if (thisChar == ' '){   [output appendString:@+];  } else if (thisChar == '.' || thisChar == '-' || thisChar == '_' || thisChar == '~' ||    (thisChar &gt;= 'a' &amp;&amp; thisChar = 'A' &amp;&amp; thisChar = '0' &amp;&amp; thisChar &lt;= '9')) {   [output appendFormat:@%c, thisChar];  } else {   [output appendFormat:@%%X, thisChar];  }  }  return output; } 46、计算UILabel上某段文字的frame @implementation UILabel (TextRect) - (CGRect)boundingRectForCharacterRange:(NSRange)range {  NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:[self attributedText]];  NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];  [textStorage addLayoutManager:layoutManager];  NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:[self bounds].size];  textContainer.lineFragmentPadding = 0;  [layoutManager addTextContainer:textContainer];  NSRange glyphRange;  [layoutManager characterRangeForGlyphRange:range actualGlyphRange:&amp;glyphRange];  return [layoutManager boundingRectForGlyphRange:glyphRange inTextContainer:textContainer]; } 47、获取随机UUID NSString *result;  if([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 6.0)  {  result = [[NSUUID UUID] UUIDString];  }  else  {  CFUUIDRef uuidRef = CFUUIDCreate(NULL);  CFStringRef uuid = CFUUIDCreateString(NULL, uuidRef);  CFRelease(uuidRef);  result = (__bridge_transfer NSString *)uuid;  } 48、仿苹果抖动动画 #define RADIANS(degrees) (((degrees) * M_PI) / 180.0) - (void)startAnimate {  view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(-5));  [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionRepeat | UIViewAnimationOptionAutoreverse) animations:^ {     view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(5));    } completion:nil]; } - (void)stopAnimate {  [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveLinear) animations:^ {     view.transform = CGAffineTransformIdentity;    } completion:nil]; } 49、修改UISearBar内部背景颜色 UITextField *textField = [_searchBar valueForKey:@_searchField]; textField.backgroundColor = [UIColor redColor]; 50、UITextView滚动到顶部  方法一 [self.textView scrollRangeToVisible:NSMakeRange(0, 0)]; 方法二 [self.textView setContentOffset:CGPointZero animated:YES]; 51、通知监听APP生命周期 UIApplicationDidEnterBackgroundNotification 应用程序进入后台 UIApplicationWillEnterForegroundNotification 应用程序将要进入前台 UIApplicationDidFinishLaunchingNotification 应用程序完成启动 UIApplicationDidFinishLaunchingNotification 应用程序由挂起变的活跃 UIApplicationWillResignActiveNotification 应用程序挂起(有电话进来或者锁屏) UIApplicationDidReceiveMemoryWarningNotification 应用程序收到内存警告 UIApplicationDidReceiveMemoryWarningNotification 应用程序终止(后台杀死、手机关机等) UIApplicationSignificantTimeChangeNotification 当有重大时间改变(凌晨0点，设备时间被修改，时区改变等) UIApplicationWillChangeStatusBarOrientationNotification 设备方向将要改变 UIApplicationDidChangeStatusBarOrientationNotification 设备方向改变 UIApplicationWillChangeStatusBarFrameNotification 设备状态栏frame将要改变 UIApplicationDidChangeStatusBarFrameNotification 设备状态栏frame改变 UIApplicationBackgroundRefreshStatusDidChangeNotification 应用程序在后台下载内容的状态发生变化 UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件被锁定,无法访问 UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件可用了 52、触摸事件类型 UIControlEventTouchCancel 取消控件当前触发的事件 UIControlEventTouchDown 点按下去的事件 UIControlEventTouchDownRepeat 重复的触动事件 UIControlEventTouchDragEnter 手指被拖动到控件的边界的事件 UIControlEventTouchDragExit 一个手指从控件内拖到外界的事件 UIControlEventTouchDragInside 手指在控件的边界内拖动的事件 UIControlEventTouchDragOutside 手指在控件边界之外被拖动的事件 UIControlEventTouchUpInside 手指处于控制范围内的触摸事件 UIControlEventTouchUpOutside 手指超出控制范围的控制中的触摸事件 53、UITextField文字周围增加边距  子类化UITextField，增加insert属性 @interface WZBTextField : UITextField @property (nonatomic, assign) UIEdgeInsets insets; @end 在.m文件重写下列方法 - (CGRect)textRectForBounds:(CGRect)bounds {  CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);  if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {  return [self adjustRectWithWidthRightView:paddedRect];  }  return paddedRect; } - (CGRect)placeholderRectForBounds:(CGRect)bounds {  CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets); if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {  return [self adjustRectWithWidthRightView:paddedRect];  }  return paddedRect; } - (CGRect)editingRectForBounds:(CGRect)bounds {  CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);  if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeWhileEditing) {  return [self adjustRectWithWidthRightView:paddedRect];  }  return paddedRect; } - (CGRect)adjustRectWithWidthRightView:(CGRect)bounds {  CGRect paddedRect = bounds;  paddedRect.size.width -= CGRectGetWidth(self.rightView.frame); return paddedRect; } 54、监听UISlider拖动状态  添加事件 [slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged]; 实现方法 - (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event {  UITouch *touchEvent = [[event allTouches] anyObject];  switch (touchEvent.phase) {  case UITouchPhaseBegan:   NSLog(@开始拖动);   break;  case UITouchPhaseMoved:   NSLog(@正在拖动);   break;  case UITouchPhaseEnded:   NSLog(@结束拖动);   break;  default:   break;  } } 55、设置UITextField光标位置  textField需要设置的textField，index要设置的光标位置 - (void)cursorLocation:(UITextField *)textField index:(NSInteger)index {  NSRange range = NSMakeRange(index, 0);  UITextPosition *start = [textField positionFromPosition:[textField beginningOfDocument] offset:range.location];  UITextPosition *end = [textField positionFromPosition:start offset:range.length];  [textField setSelectedTextRange:[textField textRangeFromPosition:start toPosition:end]]; } 56、去除webView底部黑色 [webView setBackgroundColor:[UIColor clearColor]]; [webView setOpaque:NO]; for (UIView *v1 in [webView subviews]) {  if ([v1 isKindOfClass:[UIScrollView class]])  {  for (UIView *v2 in v1.subviews)  {   if ([v2 isKindOfClass:[UIImageView class]])   {    v2.hidden = YES;   }  }  } } 57、获取collectionViewCell在屏幕中的frame UICollectionViewLayoutAttributes *attributes = [collectionView layoutAttributesForItemAtIndexPath:indexPath]; CGRect cellRect = attributes.frame; CGRect cellFrameInSuperview = [collectionView convertRect:cellRect toView:[cv superview]]; 58、比较两个UIImage是否相等 - (BOOL)image:(UIImage *)image1 isEqualTo:(UIImage *)image2 {  NSData *data1 = UIImagePNGRepresentation(image1);  NSData *data2 = UIImagePNGRepresentation(image2); return [data1 isEqual:data2]; } 59、解决当UIScrollView上有UIButton的时候，触摸到button滑动不了的问题  子类化UIScrollView，并重写以下方法 - (instancetype)initWithFrame:(CGRect)frame {  if (self = [super initWithFrame:frame]) {  self.delaysContentTouches = NO;  } return self; } - (BOOL)touchesShouldCancelInContentView:(UIView *)view {  if ([view isKindOfClass:UIButton.class]) {  return YES;  } return [super touchesShouldCancelInContentView:view]; } 60、UITextView中的文字添加阴影效果 - (void)setTextLayer:(UITextView *)textView color:(UIColor *)color {  CALayer *textLayer = ((CALayer *)[textView.layer.sublayers objectAtIndex:0]);  textLayer.shadowColor = color.CGColor;  textLayer.shadowOffset = CGSizeMake(0.0f, 1.0f);  textLayer.shadowOpacity = 1.0f;  textLayer.shadowRadius = 1.0f; } 61、MD5加密 + (NSString *)md5:(NSString *)str {  const char *concat_str = [str UTF8String];  unsigned char result[CC_MD5_DIGEST_LENGTH];  CC_MD5(concat_str, (unsigned int)strlen(concat_str), result);  NSMutableString *hash = [NSMutableString string];  for (int i =0; i&lt;16; i++){  [hash appendFormat:@X, result[i]];  }  return [hash uppercaseString]; } 62、base64加密 @interface NSData (Base64) /** * @brief 字符串base64后转data */ + (NSData *)dataWithBase64EncodedString:(NSString *)string {  if (![string length]) return nil;  NSData *decoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0  if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)])  { #pragma clang diagnostic push #pragma clang diagnostic ignored -Wdeprecated-declarations  decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@[^A-Za-z0-9+/=] withString:@ options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]]; #pragma clang diagnostic pop  }  else #endif  {  decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters];  }  return [decoded length]? decoded: nil; } /** * @brief NSData转string * @param wrapWidth 换行长度 76 64 */ - (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth {  if (![self length]) return nil;  NSString *encoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0  if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)])  { #pragma clang diagnostic push #pragma clang diagnostic ignored -Wdeprecated-declarations  encoded = [self base64Encoding]; #pragma clang diagnostic pop }  else #endif  {  switch (wrapWidth)  {   case 64:   {    return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];   }   case 76:   {    return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength];   }   default:   {    encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];   }  }  }  if (!wrapWidth || wrapWidth &gt;= [encoded length])  {  return encoded;  }  wrapWidth = (wrapWidth / 4) * 4;  NSMutableString *result = [NSMutableString string];  for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth)  {  if (i + wrapWidth &gt;= [encoded length])  {   [result appendString:[encoded substringFromIndex:i]];   break;  }  [result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]];  [result appendString:@  r  ];  }  return result; } /** * @brief NSData转string 换行长度默认64 */ - (NSString *)base64EncodedString {  return [self base64EncodedStringWithWrapWidth:0]; } 63、AES加密 #import @interface NSData (AES) /** * 利用AES加密数据 */ - (NSData*)encryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved;  NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128]; CCCryptorStatus status = CCCrypt(kCCEncrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes, encryptedData.length,&amp;dataMoved); if (status == kCCSuccess) {  encryptedData.length = dataMoved;  return encryptedData;  } return nil; } /** * @brief 利用AES解密据 */ - (NSData*)decryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved;  NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128]; CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes, decryptedData.length,&amp;dataMoved); if (result == kCCSuccess) {  decryptedData.length = dataMoved;  return decryptedData;  } return nil; } 64、3DES加密 #import @interface NSData (3DES) /** * 利用3DES加密数据 */ - (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved;  NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved); if (result == kCCSuccess) {  encryptedData.length = dataMoved;  return encryptedData;  } return nil; } /** * @brief 利用3DES解密数据 */ - (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved;  NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved); if (result == kCCSuccess) {  decryptedData.length = dataMoved;  return decryptedData;  } return nil; } 65、单个页面多个网络请求的情况，需要监听所有网络请求结束后刷新UI dispatch_group_t group = dispatch_group_create();  dispatch_queue_t serialQueue = dispatch_queue_create(com.wzb.test.www, DISPATCH_QUEUE_SERIAL);  dispatch_group_enter(group);  dispatch_group_async(group, serialQueue, ^{  // 网络请求一  [WebClick getDataSuccess:^(ResponseModel *model) {   dispatch_group_leave(group);  } failure:^(NSString *err) {   dispatch_group_leave(group);  }];  });  dispatch_group_enter(group);  dispatch_group_async(group, serialQueue, ^{  // 网络请求二  [WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) {   dispatch_group_leave(group);  }      failure:^(NSString *errorString) {   dispatch_group_leave(group);  }];  });  dispatch_group_enter(group);  dispatch_group_async(group, serialQueue, ^{  // 网络请求三  [WebClick getDataSuccess:^{   dispatch_group_leave(group);  } failure:^(NSString *errorString) {   dispatch_group_leave(group);  }];  }); // 所有网络请求结束后会来到这个方法  dispatch_group_notify(group, serialQueue, ^{  dispatch_async(dispatch_get_global_queue(0, 0), ^{   dispatch_async(dispatch_get_main_queue(), ^{    // 刷新UI   });  });  }); 66、解决openUrl延时问题  方法一 dispatch_async(dispatch_get_main_queue(), ^{ UIApplication *application = [UIApplication sharedApplication];  if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {  [application openURL:URL options:@{}  completionHandler:nil];  } else {  [application openURL:URL];  }  }); 方法二 [self performSelector:@selector(redirectToURL:) withObject:url afterDelay:0.1]; - (void) redirectToURL { UIApplication *application = [UIApplication sharedApplication];  if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {  [application openURL:URL options:@{}  completionHandler:nil];  } else {  [application openURL:URL];  } } 67、页面跳转实现翻转动画  modal方式 TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical; [self presentViewController:vc animated:YES completion:nil]; push方式 TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; [UIView beginAnimations:@View Flip context:nil]; [UIView setAnimationDuration:0.80]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO]; [self.navigationController pushViewController:vc animated:YES]; [UIView commitAnimations]; 68、tableView实现无限滚动 - (void)scrollViewDidScroll:(UIScrollView *)scrollView {  CGFloat actualPosition = scrollView.contentOffset.y;  CGFloat contentHeight = scrollView.contentSize.height - scrollView.frame.size.height;  if (actualPosition &gt;= contentHeight) {  [self.dataArr addObjectsFromArray:self.dataArr];  [self.tableView reloadData];  } } 69、代码方式调整屏幕亮度 // brightness属性值在0-1之间，0代表最小亮度，1代表最大亮度 [[UIScreen mainScreen] setBrightness:0.5]; 70、获取当前应用CUP用量 float cpu_usage() {  kern_return_t kr;  task_info_data_t tinfo;  mach_msg_type_number_t task_info_count; task_info_count = TASK_INFO_MAX;  kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);  if (kr != KERN_SUCCESS) {  return -1;  } task_basic_info_t basic_info;  thread_array_t  thread_list;  mach_msg_type_number_t thread_count; thread_info_data_t  thinfo;  mach_msg_type_number_t thread_info_count; thread_basic_info_t basic_info_th;  uint32_t stat_thread = 0; // Mach threads basic_info = (task_basic_info_t)tinfo; // get threads in the task  kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);  if (kr != KERN_SUCCESS) {  return -1;  }  if (thread_count &gt; 0)  stat_thread += thread_count; long tot_sec = 0;  long tot_usec = 0;  float tot_cpu = 0;  int j; for (j = 0; j &lt; (int)thread_count; j++)  {  thread_info_count = THREAD_INFO_MAX;  kr = thread_info(thread_list[j], THREAD_BASIC_INFO,     (thread_info_t)thinfo, &amp;thread_info_count);  if (kr != KERN_SUCCESS) {   return -1;  }  basic_info_th = (thread_basic_info_t)thinfo;  if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) {   tot_sec = tot_sec + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;   tot_usec = tot_usec + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;   tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;  } } // for each thread kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));  assert(kr == KERN_SUCCESS); return tot_cpu; } 71、float数据取整四舍五入 CGFloat f = 4.65; NSLog(@%d, (int)f); // 打印结果4 CGFloat f = 4.65; NSLog(@%d, (int)round(f)); // 打印结果5 72、删除UISearchBar系统默认边框  方法一 searchBar.searchBarStyle = UISearchBarStyleMinimal; 方法二 [searchBar setBackgroundImage:[[UIImage alloc]init]]; 方法三 searchBar.barTintColor = [UIColor whiteColor]; 73、为UICollectionViewCell设置圆角和阴影 cell.contentView.layer.cornerRadius = 2.0f; cell.contentView.layer.borderWidth = 1.0f; cell.contentView.layer.borderColor = [UIColor clearColor].CGColor; cell.contentView.layer.masksToBounds = YES; cell.layer.shadowColor = [UIColor lightGrayColor].CGColor; cell.layer.shadowOffset = CGSizeMake(0, 2.0f); cell.layer.shadowRadius = 2.0f; cell.layer.shadowOpacity = 1.0f; cell.layer.masksToBounds = NO; cell.layer.shadowPath = [UIBezierPath bezierPathWithRoundedRect:cell.bounds cornerRadius:cell.contentView.layer.cornerRadius].CGPath; 74、让正在滑动的scrollView停止滚动(不是禁止，而是暂时停止滚动) [scrollView setContentOffset:scrollView.contentOffset animated:NO]; 75、使用xib设置UIView的边框、圆角  圆角和边框看下图即可设置 但是增加layer.borderColor的keyPath设置边框颜色并不能起作用，后来查了资料，这里应该用layer.borderUIColor，但是这里设置的颜色不起作用，无论设置什么颜色显示出来的都是黑色的。后来又去查了下，有种解决方案是给CALayer添加一个分类，提供一个 - (void)setBorderUIColor:(UIColor *)color;方法就可以解决了，实现如下：  #import CALayer+BorderColor.h @implementation CALayer (BorderColor) - (void)setBorderUIColor:(UIColor *)color {  self.borderColor = color.CGColor; } 76、根据经纬度获取城市等信息  创建经纬度 CLLocation *location = [[CLLocation alloc] initWithLatitude:latitude longitude:longitude]; //创建一个译码器 CLGeocoder *cLGeocoder = [[CLGeocoder alloc] init]; [cLGeocoder reverseGeocodeLocation:userLocation completionHandler:^(NSArray *placemarks, NSError *error) {  CLPlacemark *place = [placemarks objectAtIndex:0];  // 位置名 　　NSLog(@name,%@,place.name); 　　// 街道 　　NSLog(@thoroughfare,%@,place.thoroughfare); 　　// 子街道 　　NSLog(@subThoroughfare,%@,place.subThoroughfare); 　　// 市 　　NSLog(@locality,%@,place.locality); 　　// 区 　　NSLog(@subLocality,%@,place.subLocality); 　　// 国家 　　NSLog(@country,%@,place.country);  } }]; /* CLPlacemark中属性含义 name    地名 thoroughfare  街道 subThoroughfare  街道相关信息，例如门牌等 locality   城市 subLocality  城市相关信息，例如标志性建筑 administrativeArea 直辖市 subAdministrativeArea 其他行政区域信息（自治区等） postalCode   邮编 ISOcountryCode  国家编码 country   国家 inlandWater  水源，湖泊 ocean   海洋 areasOfInterest  关联的或利益相关的地标 */ 77、如何防止添加多个NSNotification观察者？  解决方案就是添加观察者之前先移除下这个观察者 [[NSNotificationCenter defaultCenter] removeObserver:observer name:name object:object]; [[NSNotificationCenter defaultCenter] addObserver:observer selector:selector name:name object:object]; 78、将一个xib添加到另外一个xib上  假设你的自定义view名字为CustomView，你需要在CustomView.m中重写 - (instancetype)initWithCoder:(NSCoder *)aDecoder 方法，代码如下： - (instancetype)initWithCoder:(NSCoder *)aDecoder {  if ((self = [super initWithCoder:aDecoder])) {  [self addSubview:[[[NSBundle mainBundle] loadNibNamed:@CustomView owner:self options:nil] objectAtIndex:0]];  }  return self; } 79、处理字符串，使其首字母大写 NSString *str = @abcdefghijklmn; NSString *resultStr; if (str &amp;&amp; str.length &gt; 0) {  resultStr = [str stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[str substringToIndex:1] capitalizedString]]; } NSLog(@%@, resultStr); 80、判断一个UIAlertView/UIAlertController是否显示  UIAlertView自带属性 if (alert.visible) {  NSLog(@显示了); } else {  NSLog(@未显示); } UIAlertController没有visible属性，需要自己判断，添加一个全局变量 BOOL visible UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@Title message:@message preferredStyle:UIAlertControllerStyleAlert];  UIAlertAction *alertAction = [UIAlertAction actionWithTitle:@ActionTitle style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {  self.visible = NO;  }];  UIAlertAction *calcelAction = [UIAlertAction actionWithTitle:@calcelTitle style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {  self.visible = NO;  }];  [alertController addAction:alertAction];  [alertController addAction:calcelAction];  [self presentViewController:alertController animated:YES completion:^{  self.visible = YES;  }]; 81、获取字符串中的数字 - (NSString *)getNumberFromStr:(NSString *)str {  NSCharacterSet *nonDigitCharacterSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];  return [[str componentsSeparatedByCharactersInSet:nonDigitCharacterSet] componentsJoinedByString:@]; } 6  NSLog(@%@, [self getNumberFromStr:@a0b0c1d2e3f4fda8fa8fad9fsad23]); // 00123488923 82、为UIView的某个方向添加边框  添加UIView分类 UIView+WZB.h #import /** 边框方向 - WZBBorderDirectionTop: 顶部 - WZBBorderDirectionLeft: 左边 - WZBBorderDirectionBottom: 底部 - WZBBorderDirectionRight: 右边 */ typedef NS_ENUM(NSInteger, WZBBorderDirectionType) {  WZBBorderDirectionTop = 0,  WZBBorderDirectionLeft,  WZBBorderDirectionBottom,  WZBBorderDirectionRight }; @interface UIView (WZB) /** 为UIView的某个方向添加边框 @param direction 边框方向 @param color 边框颜色 @param width 边框宽度 */ - (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width; @end // UIView+WZB.m #import UIView+WZB.h @implementation UIView (WZB) - (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width {  CALayer *border = [CALayer layer];  border.backgroundColor = color.CGColor;  switch (direction) {  case WZBBorderDirectionTop:  {   border.frame = CGRectMake(0.0f, 0.0f, self.bounds.size.width, width);  }   break;  case WZBBorderDirectionLeft:  {   border.frame = CGRectMake(0.0f, 0.0f, width, self.bounds.size.height);  }   break;  case WZBBorderDirectionBottom:  {   border.frame = CGRectMake(0.0f, self.bounds.size.height - width, self.bounds.size.width, width);  }   break;  case WZBBorderDirectionRight:  {   border.frame = CGRectMake(self.bounds.size.width - width, 0, width, self.bounds.size.height);  }   break;  default:   break;  }  [self.layer addSublayer:border]; } 83、通过属性设置UISwitch、UIProgressView等控件的宽高 mySwitch.transform = CGAffineTransformMakeScale(5.0f, 5.0f); progressView.transform = CGAffineTransformMakeScale(5.0f, 5.0f); 84、自动搜索功能，用户连续输入的时候不搜索，用户停止输入的时候自动搜索(我这里设置的是0.5s，可根据需求更改)  输入框文字改变的时候调用 -(void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText{  // 先取消调用搜索方法  [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(searchNewResult) object:nil];  // 0.5秒后调用搜索方法  [self performSelector:@selector(searchNewResult) withObject:nil afterDelay:0.5]; } 85、修改UISearchBar的占位文字颜色  方法一（推荐使用） UITextField *searchField = [searchBar valueForKey:@_searchField]; [searchField setValue:[UIColor blueColor] forKeyPath:@_placeholderLabel.textColor]; 方法二（已过期） [[UILabel appearanceWhenContainedIn:[UISearchBar class], nil] setTextColor:[UIColor redColor]]; 方法三（已过期） NSDictionary *placeholderAttributes = @{NSForegroundColorAttributeName : [UIColor redColor], NSFontAttributeName : [UIFont fontWithName:@HelveticaNeue size:15],}; NSAttributedString *attributedPlaceholder = [[NSAttributedString alloc] initWithString:searchBar.placeholder attributes:placeholderAttributes]; [[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setAttributedPlaceholder:attributedPlaceholder]; 86、某个界面多个事件同时响应引起的问题(比如，两个button同时按push到新界面，两个都会响应，可能导致push重叠)  UIView有个属性叫做exclusiveTouch，设置为YES后，其响应事件会和其他view互斥(有其他view事件响应的时候点击它不起作用)view.exclusiveTouch = YES; 一个一个设置太麻烦了，可以全局设置 [[UIView appearance] setExclusiveTouch:YES]; 或者只设置button [[UIButton appearance] setExclusiveTouch:YES]; 87、修改tabBar的frame  子类化UITabBarViewController，我这里以修改tabBar高度为例，重写viewWillLayoutSubviews方法 #import WZBTabBarViewController.h @interface WZBTabBarViewController () @end @implementation WZBTabBarViewController - (void)viewWillLayoutSubviews { CGRect tabFrame = self.tabBar.frame;  tabFrame.size.height = 100;  tabFrame.origin.y = self.view.frame.size.height - 100;  self.tabBar.frame = tabFrame; } @end 88、修改键盘背景颜色  设置某个键盘颜色 textField.keyboardAppearance = UIKeyboardAppearanceAlert; 设置工程中所有键盘颜色 [[UITextField appearance] setKeyboardAppearance:UIKeyboardAppearanceAlert]; 89、修改image颜色 UIImage *image = [UIImage imageNamed:@test];  imageView.image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];  CGRect rect = CGRectMake(0, 0, image.size.width, image.size.height);  UIGraphicsBeginImageContext(rect.size);  CGContextRef context = UIGraphicsGetCurrentContext();  CGContextClipToMask(context, rect, image.CGImage);  CGContextSetFillColorWithColor(context, [[UIColor redColor] CGColor]);  CGContextFillRect(context, rect);  UIImage *img = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext(); UIImage *flippedImage = [UIImage imageWithCGImage:img.CGImage scale:1.0 orientation: UIImageOrientationDownMirrored];  imageView.image = flippedImage; 90、动画执行removeFromSuperview [UIView animateWithDuration:0.2   animations:^{    view.alpha = 0.0f;   } completion:^(BOOL finished){    [view removeFromSuperview];   }]; 91、设置UIButton高亮背景颜色 [UIView animateWithDuration:0.2   animations:^{    view.alpha = 0.0f;   } completion:^(BOOL finished){    [view removeFromSuperview];   }]; 92、设置UIButton高亮时的背景颜色  方法一、子类化UIButton，重写setHighlighted:方法，代码如下 #import WZBButton.h @implementation WZBButton - (void)setHighlighted:(BOOL)highlighted {  [super setHighlighted:highlighted]; UIColor *normalColor = [UIColor greenColor];  UIColor *highlightedColor = [UIColor redColor];  self.backgroundColor = highlighted ? highlightedColor : normalColor; } 方法二、利用setBackgroundImage:forState:方法 [button setBackgroundImage:[self imageWithColor:[UIColor blueColor]] forState:UIControlStateHighlighted]; - (UIImage *)imageWithColor:(UIColor *)color {  CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);  UIGraphicsBeginImageContext(rect.size);  CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]);  CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext();  UIGraphicsEndImageContext(); return image; } 93、关于图片拉伸  推荐看这个博客，讲的很详细：http://blog.csdn.net/q199109106q/article/details/8615661 94、利用runtime获取一个类所有属性 - (NSArray *)allPropertyNames:(Class)aClass {  unsigned count;  objc_property_t *properties = class_copyPropertyList(aClass, &amp;count); NSMutableArray *rv = [NSMutableArray array]; unsigned i;  for (i = 0; i &lt; count; i++)  {  objc_property_t property = properties[i];  NSString *name = [NSString stringWithUTF8String:property_getName(property)];  [rv addObject:name];  } free(properties); return rv; } 95、设置textView的某段文字变成其他颜色 - (void)setupTextView:(UITextView *)textView text:(NSString *)text color:(UIColor *)color {  NSMutableAttributedString *string = [[NSMutableAttributedString alloc]initWithString:textView.text];  [string addAttribute:NSForegroundColorAttributeName value:color range:[textView.text rangeOfString:text]];  [textView setAttributedText:string]; } 96、让push跳转动画像modal跳转动画那样效果(从下往上推上来) - (void)push { TestViewController *vc = [[TestViewController alloc] init];  vc.view.backgroundColor = [UIColor redColor];  CATransition* transition = [CATransition animation];  transition.duration = 0.4f;  transition.type = kCATransitionMoveIn;  transition.subtype = kCATransitionFromTop;  [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];  [self.navigationController pushViewController:vc animated:NO]; } - (void)pop { CATransition* transition = [CATransition animation];  transition.duration = 0.4f;  transition.type = kCATransitionReveal;  transition.subtype = kCATransitionFromBottom;  [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];  [self.navigationController popViewControllerAnimated:NO]; } 97、上传图片太大，压缩图片 -(UIImage *)resizeImage:(UIImage *)image {  float actualHeight = image.size.height;  float actualWidth = image.size.width;  float maxHeight = 300.0;  float maxWidth = 400.0;  float imgRatio = actualWidth/actualHeight;  float maxRatio = maxWidth/maxHeight;  float compressionQuality = 0.5;//50 percent compression if (actualHeight &gt; maxHeight || actualWidth &gt; maxWidth)  {  if(imgRatio &lt; maxRatio)  {   //adjust width according to maxHeight   imgRatio = maxHeight / actualHeight;   actualWidth = imgRatio * actualWidth;   actualHeight = maxHeight;  }  else if(imgRatio &gt; maxRatio)  {   //adjust height according to maxWidth   imgRatio = maxWidth / actualWidth;   actualHeight = imgRatio * actualHeight;   actualWidth = maxWidth;  }  else  {   actualHeight = maxHeight;   actualWidth = maxWidth;  }  } CGRect rect = CGRectMake(0.0, 0.0, actualWidth, actualHeight);  UIGraphicsBeginImageContext(rect.size);  [image drawInRect:rect];  UIImage *img = UIGraphicsGetImageFromCurrentImageContext();  NSData *imageData = UIImageJPEGRepresentation(img, compressionQuality);  UIGraphicsEndImageContext(); return [UIImage imageWithData:imageData]; } ",
      "url"      : "http://localhost:4000/2017/07/12/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7(%E4%BA%8C)/"
    } ,
  
    {
      "title"    : "Swift,Objective-C混编解析网络数据并实现简单的轮播功能",
      "category" : "iOS",
      "content": "Swift,Objective-C混编解析网络数据并实现简单的轮播功能 作者:AustinKuture  此次的轮播功能主要是在Swift语言环境下实现,并使用之前Objective-C语言封装的网络加载方法进行桥接. Swift,苹果于2014年WWDC（苹果开发者大会）发布的新开发语言,Swift既可以用于移动端的开发同时也是后台语言. Swift 结合了 C 和 Objective-C 的优点并且不受C兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，他的降临将重新定义软件开发。 最终效果图: 原始Json格式为(如下图所示): 转换之后的图片数组中的数据为: [http://img5.imgtn.bdimg.com/it/u=3892625903,3160473172&amp;fm=200&amp;gp=0.jpg, http://img8.zol.com.cn/bbs/upload/12598/12597929.gif, http://img1.imgtn.bdimg.com/it/u=4016983972488925180&amp;fm=200&amp;gp=0.jpg, http://img8.zol.com.cn/bbs/upload/12598/12597929.gif, http://img5.imgtn.bdimg.com/it/u=38926259033160473172&amp;fm=200&amp;gp=0.jpg] 1,整体目录结构 2,创建控制器,并在当前控制器中编写轮播图层 //当前控制器属性  @IBOutlet weak var homeTableView: UITableView!  @IBOutlet weak var cycleScrollViewNew: WRCycleScrollView! //下拉刷新控制器  private var refreshControl = UIRefreshControl() override func viewDidLoad() {  super.viewDidLoad()  view.backgroundColor = UIColor.white  //首页初始化  homeViewControllerInitSetting()  setupHomeObtainDataFromNetWork() } //home控制器初始化方法 fileprivate func homeViewControllerInitSetting(){  //设置Navigation  navigationController?.navigationBar.barStyle = UIBarStyle.blackTranslucent  UIApplication.shared.statusBarStyle = UIStatusBarStyle.lightContent  navigationController?.navigationBar.tintColor = UIColor.white  //设置刷新视图  refreshControl.addTarget(self, action: #selector(refreshViewMethod), for: UIControlEvents.valueChanged)  refreshControl.attributedTitle = NSAttributedString(string: 下拉刷新)  homeTableView.addSubview(refreshControl)  } //轮播方法 fileprivate func cycleScrollViewMethod(){   print(=====PIC:  (self.cyclePicArray));  cycleScrollViewNew = WRCycleScrollView(frame: cycleframe , type: .SERVER, imgs: self.cyclePicArray, descs: self.titleLabelArray)  cycleScrollViewNew?.delegate = self  homeTableView.tableHeaderView = cycleScrollViewNew  } //下拉刷新方法  func refreshViewMethod(){  print(下拉刷新)  setupHomeObtainDataFromNetWork()  //延时  DispatchQueue.main.asyncAfter(deadline: .now() + 2) {   self.refreshControl.endRefreshing()  } } } //轮播代理方法的实现 extension AKHomeController : WRCycleScrollViewDelegate { //轮播点击方法  func cycleScrollViewDidSelect(at index: Int, cycleScrollView: WRCycleScrollView) {  print(你点击了第  (index + 1)张图片)  let cycleDetail = AKHomeCycleDetail()  navigationController?.pushViewController(cycleDetail, animated: true)  } } //当前控制器出现与消失的方法 extension AKHomeController{ override func viewDidAppear(_ animated: Bool) {  tabBarController?.tabBar.isHidden = false  } } 3.调用已经封装的网络加载方法,实现数据的解析 //加载网络数据 extension AKHomeController{ func setupHomeObtainDataFromNetWork(){  let netPack = AKNetPackegeAFN.shareHttpManager()  let url = http://192.168.199.244/iOS/Swift/cycleScroll.html  //封装的网络加载方法  netPack?.netWorkType(AKNetWorkGET, signature: nil, api: url, parameters: nil, requestTimes: 10, success: { (Json) in  //将网络加载的NSAarray,NSDictionary等类型转换为Data类型  let datJ = self.jsonToData(jsonDic: Json as! NSArray)  let model = JSON(data: datJ!)  //数据数组  var titleArrayM = Array&lt;String&gt;()  var detailIDM = Array&lt;String&gt;()  var cyclePicM = Array&lt;String&gt;()  for i in 0 ..&lt; model.count {   //将要添加的数据转换为String类型并拼接到String类型的Array里   titleArrayM.append(String(describing: model[i][cycleTitle]))   detailIDM.append(String(describing: model[i][cycleDetailID]))   cyclePicM.append(String(describing: model[i][cyclePic]))  }  self.titleLabelArray = titleArrayM  self.detailIDArray = detailIDM  self.cyclePicArray = cyclePicM  //轮播  self.cycleScrollViewMethod()  self.homeTableView.reloadData()  }, fail: { (Error) in  print(HomeCycleError:  (String(describing: Error)))  })  }  //将请求到的数组转换为Data  fileprivate func jsonToData(jsonDic:NSArray) -&gt;Data?{ if(!JSONSerialization.isValidJSONObject(jsonDic)) { print(is not a valid json object) return nil } //利用自带的json库转换成Data //如果设置options为JSONSerialization.WritingOptions.prettyPrinted，则打印格式更好阅读 let data = try? JSONSerialization.data(withJSONObject: jsonDic, options: []) //Data转换成String打印输出 let str = String(data:data!, encoding: String.Encoding.utf8) //输出json字符串 print(Json Str:  (str!)) return data } } 4,网络加载方法详见另一篇博客 iOS 之Https自签名证书认证及数据请求的封装 5,整体图层 ",
      "url"      : "http://localhost:4000/2017/07/24/Swift,Objective-C%E6%B7%B7%E7%BC%96%E8%A7%A3%E6%9E%90%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%BD%AE%E6%92%AD%E5%8A%9F%E8%83%BD/"
    } ,
  
    {
      "title"    : "Python虚拟环境配置",
      "category" : "Liunx",
      "content": "一、安装和配置虚拟环境 安装虚拟环境 sudo pip install virtualenv sudo pip install virtualenvwrapper virtualenvwrapper 是virtualenv的扩展管理包，可以将所有的虚拟环境整合在一个目录下 配置虚拟环境 1.创建虚拟环境管理目录 mkdir ~/.virtrualenv 2.打开.bashrc sudo gedit ~/.bashrc 3.在.bashrc末尾增加下面内容 export WORKON_HOME=$HOME/.virtualenvs # 所有虚拟环境存储的目录 source /usr/local/bin/virtualenvwrapper.sh 3.启用配置文件 source ~/.bashrc 二、虚拟环境的操作 1.创建虚拟环境 mkvirtualenv env_name#env_name为你要创建的虚拟环境的名字，创建虚拟环境需要联网 2.创建指定python版本的虚拟环境 mkvirtualenv -p /usr/bin/python3 env_name mkvirtualenv -p /usr/bin/python2 env_name 3.运行环境 workon env_name workon + 两次tab键可以显示所有的虚拟环境 4.退出虚拟环境 deactivate 5.删除虚拟环境 rmvirtualenv env_name ",
      "url"      : "http://localhost:4000/2018/03/29/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"
    } ,
  
    {
      "title"    : "Django项目入门(一)",
      "category" : "Django",
      "content": "Django项目入门(一) 1.1创建项目 创建项目的命令如下： django-admin startproject 项目名称 为项目创建应用 python manage.py startapp 应用名字 以项目名称为DjangoSpider，应用名称为CrawlSpiders为例，当前目录结构如下图所示：  注意:应用创建完成后需要手动配置到项目中才能被使用，在settings.py中INSTALLED_APPS配置项下添加应用的名称就可以完成安装 # Application definition INSTALLED_APPS = (  'django.contrib.admin',  'django.contrib.auth',  'django.contrib.contenttypes',  'django.contrib.sessions',  'django.contrib.messages',  'django.contrib.staticfiles',  'CrawlSpiders', ) 1.2开发服务器 在开发阶段， 为了能够快速预览到开发的效果， django提供了⼀个纯python编写的轻量级web服务 器， 仅在开发阶段使⽤. 运⾏服务器命令如下： python manage.py runserver ip地址:端口 也可以不指定ip和端口，默认在127.0.0.1：8000监听： python manage.py runserver  按ctrl + c停止服务器 服务器启动后如下图所示： 在浏览器中输入网址’127.0.0.1：8000’,可以查看当前站点的开发效果  增加、修改、删除文件，服务器会自动重启 ",
      "url"      : "http://localhost:4000/2018/03/30/Django%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8(%E4%B8%80)/"
    } ,
  
    {
      "title"    : "IntelliJ IDEA",
      "category" : "Tools",
      "content": "快捷键基本与 Android Studio 一致，这里重点记录解决遇到过的问题。 Q&amp;A 解决导入 Eclipse Maven 工程后无法读取 .xml 文件的问题 IDEA 与 Eclipse 配置文件目录的方式不同，可以将文件夹标记为 Sources、Resources 和 tests 等，而 src/main/java 默认被标记为 Sources，src/main/resources 才默认被标记为 Resources，编译时自动复制。 这样放在 src/main/java 目录下的文件与子文件夹均为 Sources，只将编译生成的 .class 文件复制到编译目录，在 Eclipse Maven 工程里放在 src/main/java 文件夹里的 xml、props 和 properties 文件就不会被拷贝到编译文件夹，导致执行时找不到这些文件，报类似下面这样的错误： org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [spring-demo.xml]; nested exception is java.io.FileNotFoundException: class path resource [spring-demo.xml] cannot be opened because it does not exist  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:343)  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:303)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:216)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:187)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:251)  tat org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127)  tat org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93)  tat org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:129)  tat org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:540)  tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:454)  tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)  tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)  tat org.mazhuang.demo.protocol.db.DemoContext.init(DemoContext.java:22)  tat org.mazhuang.demo.protocol.DemoServer.start(DemoServer.java:40)  tat org.mazhuang.demo.DemoSrv.main(DemoSrv.java:17) Caused by: java.io.FileNotFoundException: class path resource [spring-demo.xml] cannot be opened because it does not exist  tat org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:158)  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:329)  t... 15 more 解决方案： 可以通过在 pom.xml 文件里添加 resources 配置来指定将哪些文件作为 resources 包含： &lt;build&gt;  &lt;resources&gt;  &lt;resource&gt;   &lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;   &lt;includes&gt;    &lt;include&gt;**/*.props&lt;/include&gt;    &lt;include&gt;**/*.xml&lt;/include&gt;   &lt;/includes&gt;  &lt;/resource&gt;  &lt;/resources&gt; &lt;/build&gt; 如何导出 jar 包 File -&gt; Project Structure -&gt; Artifacts -&gt; Click green plus sign -&gt; Jav -&gt; From modules with dependencies Build -&gt; Build Artifacts 参考  解决IntelliJ IDEA无法读取配置*.properties文件的问题 How to build jars from IntelliJ properly? ",
      "url"      : "http://localhost:4000/wiki/intellij-idea/"
    } ,
  
    {
      "title"    : "Mac OS X",
      "category" : "Mac",
      "content": "快捷键约定： C –&gt; Ctrl S –&gt; Shift M –&gt; Alt/Option Cmd –&gt; Command Mac 键盘快捷键官方参考 窗口    功能  快捷键     显示桌面  F11    切换窗口全屏状态  C-Cmd-F    隐藏当前程序的所有窗口  Cmd-H    最小化窗口  Cmd-M    关闭窗口  Cmd-W    关闭当前程序  Cmd-Q    新建标签  Cmd-T    新建窗口  Cmd-N   程序    功能  快捷键     打开 emoji 表情窗口  C-Cmd- 空格    打开 Spotlight  C- 空格    切换输入法  Cmd- 空格    打开 Alfred  M- 空格    打开 Finder 并查找  C-M- 空格    打开 Launchpad  四指合拢   命令行 快捷键    功能  按键     移动光标至行首  C-a    移动光标至行尾  C-e    清屏  C-l    清屏  C-k    删除光标前的所有文字。如果光标位于行尾则删除整行。  C-u    与退格键相同  C-h    检索使用过的命令  C-r    终止当前执行  C-c    退出当前 shell  C-d    将执行中的任何东西放入后台进程。fg 可以将其恢复。  C-z    删除光标之前的单词  C-w    删除光标后的所有文字  C-k    将光标前的两个文字进行互换  C-t    光标向前移动一个单词  C-f    光标向后移动一个单词  C-b    将光标前的两个单词进行互换  Esc + t    自动补全文件或文件夹的名称  Tab   命令    按键 / 命令  描述     cd  Home 目录    cd [folder]  切换目录    cd ~  Home 目录，例如 ‘cd ~/folder/’    cd /  根目录    ls  文件列表    ls -l  文件详细列表    ls -a  列出隐藏文件    ls -lh  文件详细列表中的文件大小以更友好的形式列出    ls -R  递归显示文件夹中的内容    sudo [command]  以超级用户身份执行命令    open [file]  打开文件 ( 相当于双击一个文件 )    top  显示运行中的进程，按 q 终止    nano [file]  打开编辑    pico [file]  打开编辑    q  退出    clear  清屏   命令历史    按键/命令  描述     history n  列出最近执行过的 n 条命令    ctrl-r  检索之前执行过的命令    ![value]  执行最近以 ‘value’ 开始的命令    !!  执行最近执行过的命令   文件管理    按键/命令  描述     touch [file]  创建一个新文件    pwd  显示当前工作目录    ..  上级目录, 例如.    ‘ls -l ..’  上级目录的文件详细列表    ‘cd ../../’  向上移动两个层级    .  当前目录    cat  连接    rm [file]  移除文件, 例如 rm [file] [file]    rm -i [file]  移除时出现确认提示    rm -r [dir]  移除文件及内容    rm -f [file]  强制移除    cp [file] [newfile]  复制文件    cp [file] [dir]  复制文件到指定目录    mv [file] [new filename]  移动 / 重命名, 例如 mv -v [file] [dir]   目录管理    按键/命令  描述     mkdir [dir]  创建新目录    mkdir -p [dir]/[dir]  创建子目录    rmdir [dir]  移除目录 ( 仅限目录下没有内容时 )    rm -R [dir]  移除目录及内容   管道 - 连接多个带有输出的命令    按键/命令  描述     more  按当前窗口大小输出内容    &gt; [file]  输出至指定文件, 注意文件将会覆盖    » [file]  在制定文件的末尾附加内容    &lt;  从文件中读取内容   帮助    按键/命令  描述     [command] -h  显示帮助信息    [command] –help  显示帮助信息    [command] help  显示帮助信息    reset  重置当前终端    man [command]  显示指定命令的帮助信息    whatis [command]  显示指定命令的简述   搜索  使用 find 命令，例如： find ~ -iname aapt   使用 mdfind 命令，例如： 全局搜索 mdfind -name aapt   或搜索指定文件夹 mdfind -onlyin ~/Library aapt   使用 locate 命令，例如： locate aapt   复制文件路径  在 Finder 下 先按键 Cmd-i，然后从弹出的窗口里复制。   在 Terminal 下 pwd|pbcopy   Safari    功能  快捷键     定位到地址栏  Cmd-L    切换标签  Cmd-S-Left/Right    收藏页面  Cmd-D   保存 Safari 里正在播放的视频 $ su # cd /private/var/folders # ls nk zz # cd nk # ls zy3770994vqg83xvmbc9pd0m0000gn # cd zy3770994vqg83xvmbc9pd0m0000gn/T # open . 然后复制里面叫 FlashTmp.xxx 的文件，改名为 FlashTmp.flv。（操作过程中保持视频在播放状态） Terminal    功能  快捷键     新建标签  Cmd-T    上 / 下个标签  Cmd-{/}    删除光标前的输入  C-U   WireShark 使用 WireShark 1.99 开发版，可以不依赖于 X11，界面基于 Qt，更加美观，符合 Mac 界面风格。 截图    功能  快捷键     全屏截图保存到桌面  Cmd-S-3    全屏截图并复制  Cmd-C-S-3    选区截图保存到桌面  Cmd-S-4    选区截图并复制  Cmd-C-S-4    窗口截图保存到桌面  Cmd-S-4 空格    窗口截图并复制  Cmd-C-S-4 空格    QQ 截图  Cmd-S-A   去除窗口截图时的阴影 defaults write com.apple.screencapture disable-shadow -bool TRUE Killall SystemUIServer 如果要保留窗口截图时的阴影，则将 TRUE 改为 FALSE。 调整选区大小 使用选区模式选中一个区域并松开鼠标前，  按住空格并移动鼠标，可以保持区域大小不变，并移动区域； 按住Shift并移动鼠标，就可以保持区域的其它三个边不变，移动一个边的位置； 按住Alt并移动鼠标，就可以对称的调整区域大小。 截图标注 使用预览工具可以完成截图标注。 延时截图 使用系统自带的 Grab 工具，运行后选择菜单的 Capture - Timed Screen。 iBooks 里的电子书保存路径 /Users/&lt;username&gt;/Library/Containers/com.apple.BKAgentService/Data/Documents/iBooks/Books 安装 mpv 没有图形界面 使用 brew options mpv 可以看到有个 --with-bundle 是安装时创建 .app 文件。 brew install mpv --with-bundle brew linkapps mpv 屏幕取色 使用 Mac 自带的“数码测色计”。 参考  你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐 terminal-mac-cheatsheet ",
      "url"      : "http://localhost:4000/wiki/mac/"
    } ,
  
    {
      "title"    : "Markdown",
      "category" : "Markdown",
      "content": "目录  超链接 列表 强调 标题 表格 代码块 图片 锚点 Emoji Footnotes mermaid sequence flowchart mathjax 超链接 [靠谱-ing](http://mazhuang.org) &lt;http://mazhuang.org&gt; 靠谱-ing http://mazhuang.org 列表 1. 有序列表项 1 2. 有序列表项 2 3. 有序列表项 3   有序列表项 1   有序列表项 2   有序列表项 3 * 无序列表项 1 * 无序列表项 2 * 无序列表项 3   无序列表项 1   无序列表项 2   无序列表项 3 任务列表 1 任务列表 2 强调 ~~删除线~~ **加黑** *斜体* 删除线 加黑 斜体 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 Tips: # 与标题中间要加空格。 表格 | HEADER1 | HEADER2 | HEADER3 | HEADER4 | | ------- | :------ | :-----: | ------: | | content | content | content | content |   HEADER1  HEADER2  HEADER3  HEADER4     content  content  content  content   :—– 表示左对齐 :—-: 表示中对齐 —–: 表示右对齐 代码块 print 'Hello, World!'   list item1   list item2 print 'hello'   图片 ![本站favicon](/favicon.ico)  锚点 * [目录](#目录) 目录 Emoji :camel: :blush: :smile: Footnotes This is a text with footnote1. mermaid sequenceDiagram  Alice--&gt;&gt;John: Hello John, how are you?  John--&gt;&gt;Alice: Great! sequence Andrew-&gt;China: Says Hello Note right of China: China thinks  about it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! flowchart st=&gt;start: Start e=&gt;end op1=&gt;operation: My Operation sub1=&gt;subroutine: My Subroutine cond=&gt;condition: Yes or No? io=&gt;inputoutput: catch something... st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op1 mathjax When , there are two solutions to and they are    Here is the footnote 1 definition. &#8617;  ",
      "url"      : "http://localhost:4000/wiki/markdown/"
    } ,
  
    {
      "title"    : "MPV",
      "category" : "Tools",
      "content": "Mac OS X 下最好用的播放器，没有之一。 快捷键 参考：mpv keybindings    按键  功能     RIGHT  前进 5 秒    LEFT  后退 5 秒    UP  前进 60 秒    DOWN  后退 60 秒    [  0.9091 倍速播放    ]  1.1 倍速播放    {  0.5 倍速播放    }  2.0 倍速播放    Backspace  还原到 1.0 倍速    Space 或 p  播放/暂停    .  下一帧    ,  上一帧    9 或 /  音量 -2    0 或 *  音量 +2    f  切换是否全屏    v  显示/隐藏字幕    T  切换是否前端显示    s  截屏，有字幕    S  截屏，无字幕    o  显示进度条与时间，2 秒后消失    I (大写 i)  显示当前文件名    1  对比度 -1    2  对比度 +1    3  亮度 -1    4  亮度 +1    5  Gamma 值 -1    6  Gamma 值 +1    7  饱和度 -1    8  饱和度 +1    l (小写 L)  设置/清除 A-B 循环点    j/J  选择字幕    #  切换声道    q  退出   命令行参数 参考：OPTIONS 参考  MPV使用小记 ",
      "url"      : "http://localhost:4000/wiki/mpv/"
    } ,
  
    {
      "title"    : "OllyDbg",
      "category" : "debug",
      "content": "快捷键 Ctrl –&gt; C Shift –&gt; S Alt –&gt; M    功能  快捷键     设置/取消断点  F2    执行到光标所在行  F4    步过  F8    步进  F7    运行  F9    暂停  F12    回到应用层  M-F9    打开文件  F3    重新调试  C-F2    打开应用程序输入表  C-n    寻找表达式  C-g    打开断点窗口  M-b    切换断点状态  空格    添加备注  ;  ",
      "url"      : "http://localhost:4000/wiki/ollydbg/"
    } ,
  
    {
      "title"    : "OneNote",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 调整文本格式    功能  Windows  Mac OS X     高亮选中文本  C-S-h 或 C-M-h       插入超链接  C-k  Cmd-k    复制选中文本的格式（格式刷）  C-S-c  Cmd-M-c    应用格式刷到选中文本  C-S-v  Cmd-M-v    打开光标下的链接  Enter  Enter    加黑  C-b  Cmd-b    斜体  C-i  Cmd-i    下划线  C-u  Cmd-u    删除线  C-Hyphen(-)  C-Cmd-Hyphen(-)    上标  C-S-=       下标  C-=       无序列表标记  C-Period(.)  Cmd-Period(.)    有序列表标记  C-Slash(/)  Cmd-Slash(/)    标题一  C-M-1  Cmd-M-1    标题六  C-M-6  Cmd-M-6    正文，清除格式  C-S-n  Cmd-S-n    增加段落缩进  M-S-Right  Cmd-]    减少段落缩进  M-S-Left  Cmd-[    左对齐  C-l  Cmd-l    右对齐  C-r  Cmd-r    增大选中文本字体  C-S-&gt;       减小选中文本字体  C-S-&lt;       在当前页面显隐基准线  C-S-r      插入元素    功能  Windows  Mac OS X     插入日期  M-S-d  Cmd-d    插入时间  M-S-t       插入日期+时间  M-S-f  Cmd-S-d   表格    功能  Windows  Mac OS X     在当前行下面新建行  C-Enter  Cmd-Enter    在当前行上面新建行  光标移到行首，Enter  光标移到行首，Enter    在当前列右边新建列  C-M-r  C-Cmd-r    在当前列左边新建列     C-Cmd-l    在当前单元格开始新段落  M-Enter      选择与移动    功能  Windows  Mac OS X     移动光标到页面标题并选中  C-S-t  Cmd-S-t    将段落上移  M-S-Up  Cmd-M-Up    将段落下移  M-S-Down  Cmd-M-Down    返回上一个访问过的页面  M-Left  C-Cmd-Left    前进到后一个访问过的页面  M-Right  C-Cmd-Right   分区与页面    功能  Windows  Mac OS X     新建页面到当前分区最后面  C-n  Cmd-n    在当前页面下新建同级页面  C-M-n  Cmd-n    在当前页面下新建子页面  C-M-S-n       增加页面层级  C-M-]  Cmd-M-]    减少页面层级  C-M-[  Cmd-M-[    选中当前页面  C-M-g  Cmd-S-a    上移当前选中页面  M-S-Up  Cmd-M-Up    下移当前选中页面  M-S-Down  Cmd-M-Down    返回访问的上一页  M-Left  C-Cmd-Left    返回访问的下一页  M-Right  C-Cmd-Right    停靠到桌面  C-M-d       显示上一个分区  C-S-Tab       显示下一个分区  C-Tab       显示当前分区的上一个页面  C-Page Up       显示当前分区的下一个页面  C-Page Down       显示当前分区的第一个页面  M-Home       显示当前分区的最后一个页面  M-End      小技巧  搜索带特殊字符如「空格」等，用 将搜索关键字括起来。   删除「我的模板」 在 Windows 下的 C:  Users  &lt;username&gt;  AppData  Roaming  Microsoft  Templates 里找到文件 我的模板.one，双击打开将显示你所有的模板页面，删除你想要删除的然后关闭即可。 参考  OneNote 2010 的键盘快捷键 Keyboard shortcuts in OneNote for Windows 10 ",
      "url"      : "http://localhost:4000/wiki/onenote/"
    } ,
  
    {
      "title"    : "PHP",
      "category" : "php",
      "content": "Q &amp; A 如何查看 php.ini 文件路径？ 新建一个 test.php 文件，内容如下： &lt;?php phpinfo(); ?&gt; 然后在浏览器使用 url 访问 test.php，会显示 php 相关的配置、插件等大量相关信息，在其中 Loaded Configuration File 一项即可找到所有生效的 php.ini 文件路径。 或者，更简单地可以直接运行命令输出以上信息（如果安装了多个版本的 php，那注意使用正确的 php 命令）： php -r phpinfo(); 本地运行一个 php 文件 php [-f] test.php 几种错误提示及对应的解决办法 提示： PHP Fatal error: Uncaught Error: Call to undefined function socket_create() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： PHP Fatal error: Uncaught Error: Call to undefined function curl_init() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： The openssl extension is required for SSL/TLS protection but is not available. If you can not enable the openssl extension, you can disable this error, at your own risk, by setting the 'disable-tls' option to true 解决办法： 在 php.ini 文件中配置启用扩展 php_openssl.dll。 在开发环境下直接在页面显示出错信息 修改 php.ini 文件，配置 display_errors = On。 安装 Memcache（not Memcached）for php7 当前（2016-10-19）Memcache 扩展并未有官方的支持办法，所以从源码编译安装。 步骤：  下载解压源码 wget https://github.com/websupport-sk/pecl-memcache/archive/NON_BLOCKING_IO_php7.zip unzip NON_BLOCKING_IO_php7.zip cd pecl-memcache-NON_BLOCKING_IO_php7   编译 /usr/local/php7/bin/phpize &amp;&amp; ./configure --enable-memcache --with-php-config=/usr/local/php7/bin/php-config &amp;&amp; make   注意 phpize 和 php-config 要使用 php7 下的。   放置 so 文件到正确位置 cp modules/memcache.so /usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012/memcache.so   目标路径可以在 phpinfo() 的 extension_dir 字段找到。   配置 echo 'extension=memcache.so' &gt; /usr/local/php7/etc/php.d/memcache.ini   目标路径可以在 phpinfo() 的 Scan this dir for addtional .ini files 字段找到。   重启服务使扩展生效 service php-fpm restart   参考 Memcache extension with PHP 7 on CentOS fails to install。 修改 php.ini 后让配置生效 service php-fpm restart ",
      "url"      : "http://localhost:4000/wiki/php/"
    } ,
  
    {
      "title"    : "Python",
      "category" : "Python",
      "content": "requests 优雅简单的 HTTP 模块。 BeautifulSoup 很好用的 HTML/XML 解析器。 json JSON 编码解码器。 应用举例：  格式化 JSON 文件 python -m json.tool src.json &gt; dst.json   在 Vim 里格式化 JSON： :%!python -m json.tool   CGIHTTPServer 简单实用的 HTTP 服务器。 应用举例：  运行一个简易的 HTTP 服务器 python -m CGIHTTPServer 80   base64 方便地进行 base64 编解码的模块。 应用举例：  解码 base64 echo aGVsbG93b3JsZA== | python -m base64 -d   则能看到输出 helloworld  ",
      "url"      : "http://localhost:4000/wiki/python/"
    } ,
  
    {
      "title"    : "Qt Creator",
      "category" : "Qt",
      "content": "快捷键（for mac） 参考：http://doc.qt.io/qtcreator/creator-keyboard-shortcuts.html C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  快捷键     自动完成  C-Space    显示/隐藏侧边栏  Cmd-0    切换已打开的文件  M-Tab    上/下一行  C-p/C-n    前进/后退一个字符  C-f/C-b    删除一个单词  M-Del    构建  Cmd-b    运行  Cmd-r    调试  Cmd-y    注释  Cmd-/    换行  Cmd-Return    跳到定义  F2    切换头文件与源文件  F4    前进/后退  M-Cmd-Left/Right    打开定位器  Cmd-k  ",
      "url"      : "http://localhost:4000/wiki/qt-creator/"
    } ,
  
    {
      "title"    : "Source Insight",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt    功能  快捷键     返回  M-,    前进  M-.    跳到定义  C-=    查找引用  C-/    搜索  C-f    向下搜索  F4    向上搜索  F3    高亮当前单词  S-F8   Q&amp;A  新建工程后函数跳转等遇到 symbol not found 如何解决？ 打开菜单里的「Project」-「Synchronize Files」（快捷键 Alt + Shift + S），勾选 Force all files to be re-parsed 后点击 OK，等待 Source Insight 重新解析工程里的文件完成即可。   如何在标题栏里显示文件全路径？ 打开菜单里的「Options」-「Preferences」-「Display」，取消勾选 Trim long path names with ellipses。  ",
      "url"      : "http://localhost:4000/wiki/source-insight/"
    } ,
  
    {
      "title"    : "Swimming",
      "category" : "Hobbies",
      "content": "蛙泳 我目前能游出最远距离的泳姿。 视频  蛙泳教学完整版 动作时序图 要领  先划手，后收腿，先伸胳膊后蹬腿。 腿部动作时一定要勾脚，大腿不要收太多。 收腿放松，蹬腿用力，蹬完一定要漂一会，把握好节奏，不要快蹬快收。 手部划水动作不要过大，不要超过肩部。 两手开始外分时就抬头吸气。 自由泳 视频  值得一看的自由泳教学视频 ",
      "url"      : "http://localhost:4000/wiki/swimming/"
    } ,
  
    {
      "title"    : "Wiki Template",
      "category" : "cate1",
      "content": "Content here ",
      "url"      : "http://localhost:4000/wiki/template/"
    } ,
  
    {
      "title"    : "Vim",
      "category" : "Vim",
      "content": "移动 以字（符）为单位    功能  按键     上  k    下  j    左  h    右  l   以单词为单位    功能  按键     前一个单词尾  ge    后一个单词首  w    本单词首（已在本词首则跳到前一单词首）  b    本单词尾（已在本词尾则跳到后一单词尾）  e   以屏幕为单位    功能  按键     向下翻页  CTRL-f    向上翻页  CTRL-b    向下翻半页  CTRL-d    向上翻半页  CTRL-u    向上一行  CTRL-y    向下一行  CTRL-e    光标移到屏幕上方  H    光标移到屏幕中间  M    光标移到屏幕下方  L    光标所在位置移到屏幕上方  zt    光标所在位置移到屏幕中间  zz    光标所在位置移到屏幕下方  zb   行号    功能  按键     跳到第 num 行  :num 或 numG 或 numgg   文件    功能  按键     跳到文件头  gg    跳到文件尾  G   编辑 复制    功能  按键     复制光标所在单词  yiw    复制光标所在行  yy   粘贴    功能  按键     在光标之后粘贴  p    在光标之前粘贴  P   剪切    功能  按键     剪切选中区域  d    剪切光标所在行  dd   替换    功能  按键     将全文中的 str1 替换为 str1  :%s/str1/str2/g    将 1 到 5 行中的 str1 替换为 str2  :1,5/str1/str2/g   大小写    功能  按键     将选中内容大小写互换  ~    将选中内容全转为小写  gu    将选中内容全转为大写  gU    将当前行变成小写  guu    将当前行变成大写  gUU   选择    功能  按键     选中上一次选择的区域  gv    选中括号内区域  vi{、vi[、vi(   搜索    功能  按键     向下查找字符串  /str    向上查找字符串  ?str    查找下一个  n    查找上一个  N    向下查找光标所在单词  *    向下查找光标所在单词  #   正则表达式    功能  按键     匹配单词左边界    &lt;    匹配单词右边界    &gt;    去重  :g/^  (.*  )$    1/d   常用    功能  按键     删除空行  :g/^$/d    撤销/UNDO  u    重做/REDO  C-r    统计行/单词/字符/字节数  g C-g   全局    功能  按键     退出  :q    强制执行  !    执行外部命令  :!   文件操作    功能  按键     打开  :e    打开文件对话框  :bro e    保存  :w    另存为对话框  :bro w    查看历史文件列表  :ol    查看并打开历史文件  :bro ol    重命名当前文件  :f filename   vimdiff    功能  按键     移动到上一个不同处  [c    移动到下一个不同处  ]c    该差异点使用当前文件的  dp    该差异点使用其它文件的  do    手动刷新重新比较  :diffupdate   Buffer    功能  按键     查看 Buffer 列表  :ls    转到 Buffer 列表中的下一个 Buffer  :bn    转到 Buffer 列表中的上一个 Buffer  :bp    转到 Buffer 列表中的 num 号 Buffer  :bnum    你之前待过的一个 Buffer  :b#    从 Buffer 列表中删除 num 号 Buffer  :bdnum   组合命令 可以使用 | 来组合命令，比如 cmd1 | cmd2。 代码    功能  按键     格式化代码  gg=G    去除 1-20 行首的行号  :1,20s/^    s  *[0-9]  *    s  *//g    展开全部折叠  zR    展开当前层级折叠  zr    全部折叠  zM    当前层级折叠  zm    切换折叠/展开  za    递归折叠/展开当前大区块  zA    折叠当前区块  zc    递归折叠当前大区块  zC    展开当前区块  zo    递归展开当前大区块  zO    格式化 json 数据  :%!python -m json.tool    缩进当前行  &gt;&gt;    反缩进当前行  &lt;&lt;   插件 CtrlP 基础按键 C-p    功能  按键     刷新列表  F5    切换文件/缓冲区/MRU  C-f/b    切换全路径搜索/文件名搜索  C-d    切换正则表达式模式  C-r    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/v/x    历史选择记录的上/下一条  C-p/n    创建文件和它的父路径  C-y    标记并打开多个文件  C-z C-o    退出 CtrlP  C-c   LeaderF    功能  按键     打开文件  Leader-f    打开缓冲区  Leader-b    打开 MRU  Leader-m（自定义的）    退出  C-c    切换模糊查找和正则查找  C-r    粘贴  C-v    清空输入  C-u    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/]/v    刷新列表  F5   vim-table-mode    功能  按键     删除列  Leader-tdc    删除行  Leader-tdd    重新格式化表格  Leader-tr  ",
      "url"      : "http://localhost:4000/wiki/vim/"
    } ,
  
    {
      "title"    : "Visual Studio Code",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  Windows  Mac OS X     打开文件  C-o       打开文件夹  C-k C-o       关闭文件夹  C-k f       命令面板  C-S-p       资源管理器  C-S-e       搜索  C-S-f       Git  C-S-g       调试  C-S-d       插件  C-S-x       Markdown 侧边预览  C-k v       Markdown 预览  C-S-v     ",
      "url"      : "http://localhost:4000/wiki/visual-studio-code/"
    } ,
  
    {
      "title"    : "Visual Studio",
      "category" : "Tools",
      "content": "地球上最好用的 C++ 开发环境，没有之一。现在也有免费的社区版了，可惜以前密集写 C++ 代码的时候没赶上。 快捷键    功能  快捷键     快速打开 anything  C-,    当前打开文件  C-M-Down    切换头/源文件  C-ko    返回  C–    前进  C-S–    跳转到定义  F12    在新窗口展示定义  M-F12    跳转到声明  C-M-F12    上/下移动行  M-Up/Down    在上面插入行  C-Enter    在下面插入行  C-S-Enter    折叠/展开当前代码段  C-mm    注释  C-kc    取消注释  C-ku    选中单词大写  C-S-u    选中单词小写  C-u    调试  F5    执行  C-F5    设置断点  F9    步过  F10    步入  F11   插件  Go To Definition Make ctrl+click perform a “Go To Definition” on the identifier under the cursor.   Visual Assist Productivity tool for C/C++ and C# that improves IDE features related to navigation, refactoring, code generation, and coding assistance. 参考  visual studio 2013 快捷键大全、VS2013常用快捷键完整页 ",
      "url"      : "http://localhost:4000/wiki/visual-studio/"
    } 
  
]


<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>iOS开发技巧(二)</title>

    <meta name="description" content="Kuture'Blog" />
    <meta name="keywords" content="Kuture,AustinKuture,Kuture'Blog,李亚坤,李亚坤的博客,Kuture的博客," />
    <meta name="author" content="Kuture" />

    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />

<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h1 id="toc_0">iOS开发技巧(二)</h1>

<p>作者:AustinKuture</p>

<h2 id="toc_1">1、设置UILabel行间距</h2>

<div><pre><code class="language-none">NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];
NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
[style setLineSpacing:20];
[attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];
label.attributedText = attrString;</code></pre></div>

<blockquote>
<p>或者使用xib，看下gif图</p>
</blockquote>

<p><img src="http://cc.cocimg.com/api/uploads/20170710/1499657090104458.gif" alt=""></p>

<h2 id="toc_2">2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h2>

<blockquote>
<p>方法一、
把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典</p>
</blockquote>

<div><pre><code class="language-none">NSArray * array = 
    [NSArray arrayWithObjects: @&quot;first&quot;, @&quot;second&quot;, nil];
[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];</code></pre></div>

<blockquote>
<p>方法二、
使用NSInvocation</p>
</blockquote>

<div><pre><code class="language-none">    SEL aSelector = NSSelectorFromString(@&quot;doSoming:argument2:&quot;);
        NSInteger argument1 = 10;
        NSString *argument2 = @&quot;argument2&quot;;
        if([self respondsToSelector:aSelector]) {
            NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];
            [inv setSelector:aSelector];
            [inv setTarget:self];
            [inv setArgument:&amp;(argument1) atIndex:2];
            [inv setArgument:&amp;(argument2) atIndex:3];
            [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];
        }</code></pre></div>

<h2 id="toc_3">3、UILabel显示不同颜色字体</h2>

<div><pre><code class="language-none"> NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];
[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];
[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];
[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];
label.attributedText = string;</code></pre></div>

<h2 id="toc_4">4、比较两个CGRect/CGSize/CGPoint是否相等</h2>

<div><pre><code class="language-none">if (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等
        // do some
    }
    if (CGPointEqualToPoint(point1, point2)) { // 两个点相等
        // do some
    }
    if (CGSizeEqualToSize(size1, size2)) { // 两个size相等
        // do some
    }</code></pre></div>

<h2 id="toc_5">5、比较两个NSDate相差多少小时</h2>

<div><pre><code class="language-none"> NSDate* date1 = someDate;
 NSDate* date2 = someOtherDate;
 NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2];
 double secondsInAnHour = 3600;
// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数
 NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;</code></pre></div>

<h2 id="toc_6">6、每个cell之间增加间距</h2>

<blockquote>
<p>方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)</p>
</blockquote>

<div><pre><code class="language-none">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return yourArry.count;
}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 1;
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    return cellSpacingHeight;
}</code></pre></div>

<blockquote>
<p>方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。</p>

<p>方法三，自定义cell，重写setFrame：方法</p>
</blockquote>

<div><pre><code class="language-none">- (void)setFrame:(CGRect)frame{

    frame.size.height -= 20;
    [super setFrame:frame];
}</code></pre></div>

<h2 id="toc_7">7、播放一张张连续的图片</h2>

<blockquote>
<p>加入现在有三张图片分别为animate<em>1、animate</em>2、animate_3
方法一</p>
</blockquote>

<div><pre><code class="language-none">    imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];
imageView.animationDuration = 1.0;</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];</code></pre></div>

<blockquote>
<p>方法二解释下，这个方法会加载animate<em>为前缀的，后边0-1024，也就是animate</em>0、animate<em>1一直到animate</em>1024</p>
</blockquote>

<h2 id="toc_8">8、加载gif图片</h2>

<p>推荐使用这个框架 FLAnimatedImage</p>

<h2 id="toc_9">9、防止离屏渲染为image添加圆角</h2>

<blockquote>
<p>image分类</p>
</blockquote>

<div><pre><code class="language-none">- (UIImage *)circleImage
{
// NO代表透明
UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);
// 获得上下文
CGContextRef ctx = UIGraphicsGetCurrentContext();
// 添加一个圆
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
// 方形变圆形
CGContextAddEllipseInRect(ctx, rect);
// 裁剪
CGContextClip(ctx);
// 将图片画上去
[self drawInRect:rect];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
return image;
}</code></pre></div>

<h2 id="toc_10">10、查看系统所有字体</h2>

<blockquote>
<p>打印字体</p>
</blockquote>

<div><pre><code class="language-none">for (id familyName in [UIFont familyNames]) {
    NSLog(@&quot;%@&quot;, familyName);
    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@&quot;  %@&quot;, fontName);
}</code></pre></div>

<blockquote>
<p>也可以进入这个网址查看 http://iosfonts.com/</p>
</blockquote>

<h2 id="toc_11">11、获取随机数</h2>

<div><pre><code class="language-none">NSInteger i = arc4random();</code></pre></div>

<h2 id="toc_12">12、获取随机数小数(0-1之间)</h2>

<div><pre><code class="language-none">#define ARC4RANDOM_MAX      0x100000000
double val = ((double)arc4random() / ARC4RANDOM_MAX);</code></pre></div>

<h2 id="toc_13">13、AVPlayer视频播放完成的通知监听</h2>

<div><pre><code class="language-none">[[NSNotificationCenter defaultCenter] 
      addObserver:self
      selector:@selector(videoPlayEnd)
      name:AVPlayerItemDidPlayToEndTimeNotification 
      object:nil];</code></pre></div>

<h2 id="toc_14">14、判断两个rect是否有交叉</h2>

<div><pre><code class="language-none"> if (CGRectIntersectsRect(rect1, rect2)) { }</code></pre></div>

<h2 id="toc_15">15、判断一个字符串是否为数字</h2>

<div><pre><code class="language-none">NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)
    {
      // 是数字
    } else
    {
      // 不是数字
    }</code></pre></div>

<h2 id="toc_16">16、将一个view保存为pdf格式</h2>

<div><pre><code class="language-none">- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename
{
    NSMutableData *pdfData = [NSMutableData data];
    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);
    UIGraphicsBeginPDFPage();
    CGContextRef pdfContext = UIGraphicsGetCurrentContext();
    [aView.layer renderInContext:pdfContext];
    UIGraphicsEndPDFContext();

    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);
    NSString* documentDirectory = [documentDirectories objectAtIndex:0];
    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];
    [pdfData writeToFile:documentDirectoryFilename atomically:YES];
    NSLog(@&quot;documentDirectoryFileName: %@&quot;,documentDirectoryFilename);
}</code></pre></div>

<h2 id="toc_17">17、让一个view在父视图中心</h2>

<div><pre><code class="language-none">child.center = [parent convertPoint:parent.center fromView:parent.superview];</code></pre></div>

<h2 id="toc_18">18、获取当前导航控制器下前一个控制器</h2>

<div><pre><code class="language-none">- (UIViewController *)backViewController
{
    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];

    if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) {
        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];
    } else {
        return nil;
    }
}</code></pre></div>

<h2 id="toc_19">19、保存UIImage到本地</h2>

<div><pre><code class="language-none">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Image.png&quot;];

[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];</code></pre></div>

<h2 id="toc_20">20、键盘上方增加工具栏</h2>

<div><pre><code class="language-none">UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];
[keyboardDoneButtonView sizeToFit];
UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;Done&quot;
                                                               style:UIBarButtonItemStyleBordered target:self
                                                              action:@selector(doneClicked:)];
[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];
txtField.inputAccessoryView = keyboardDoneButtonView;</code></pre></div>

<h2 id="toc_21">21、copy一个view</h2>

<p>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃</p>

<p>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</p>

<div><pre><code class="language-none">id copyOfView = 
[NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];</code></pre></div>

<h2 id="toc_22">22、在image上绘制文字并生成新的image</h2>

<div><pre><code class="language-none">UIFont *font = [UIFont boldSystemFontOfSize:12];
    UIGraphicsBeginImageContext(image.size);
    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];
    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);
    [[UIColor whiteColor] set];
    [text drawInRect:CGRectIntegral(rect) withFont:font]; 
    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();</code></pre></div>

<h2 id="toc_23">23、判断一个view是否为另一个view的子视图</h2>

<blockquote>
<p>如果myView是self.view本身，也会返回yes</p>
</blockquote>

<div><pre><code class="language-none">BOOL isSubView = [myView isDescendantOfView:self.view];</code></pre></div>

<h2 id="toc_24">24、判断一个字符串是否包含另一个字符串</h2>

<blockquote>
<p>方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二</p>
</blockquote>

<div><pre><code class="language-none">if ([str containsString:otherStr]) NSLog(@&quot;包含&quot;);</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">NSRange range = [str rangeOfString:otherStr];
if (range.location != NSNotFound) NSLog(@&quot;包含&quot;);</code></pre></div>

<blockquote>
<p>25、UICollectionView自动滚动到某行</p>

<p>重写viewDidLayoutSubviews方法</p>
</blockquote>

<div><pre><code class="language-none">-(void)viewDidLayoutSubviews {
   [super viewDidLayoutSubviews];
   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];
}</code></pre></div>

<h2 id="toc_25">26、修改系统UIAlertController</h2>

<blockquote>
<p>但是据说这种方法会被App Store拒绝(慎用！)</p>
</blockquote>

<div><pre><code class="language-none">UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet];
    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@&quot;我是一个大文本&quot;];
    [hogan addAttribute:NSFontAttributeName
                  value:[UIFont systemFontOfSize:30]
                  range:NSMakeRange(4, 1)];
    [hogan addAttribute:NSForegroundColorAttributeName
                  value:[UIColor redColor]
                  range:NSMakeRange(4, 1)];
    [alertVC setValue:hogan forKey:@&quot;attributedTitle&quot;];

    UIAlertAction *button = [UIAlertAction actionWithTitle:@&quot;Label text&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];
    UIImage *accessoryImage = [UIImage imageNamed:@&quot;1&quot;];
    [button setValue:accessoryImage forKey:@&quot;image&quot;];
    [alertVC addAction:button];
    [self presentViewController:alertVC animated:YES completion:nil];</code></pre></div>

<h2 id="toc_26">27、判断某一行的cell是否已经显示</h2>

<div><pre><code class="language-none">CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];
BOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);</code></pre></div>

<h2 id="toc_27">28、让导航控制器pop回指定的控制器</h2>

<div><pre><code class="language-none">NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];
for (UIViewController *aViewController in allViewControllers) {
    if ([aViewController isKindOfClass:[RequiredViewController class]]) {
        [self.navigationController popToViewController:aViewController animated:NO];
    }
}</code></pre></div>

<h2 id="toc_28">29、动画修改label上的文字</h2>

<blockquote>
<p>方法一</p>
</blockquote>

<div><pre><code class="language-none">CATransition *animation = [CATransition animation];
    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    animation.type = kCATransitionFade;
    animation.duration = 0.75;
    [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];
    self.label.text = @&quot;New&quot;;</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">[UIView transitionWithView:self.label
                      duration:0.25f
                       options:UIViewAnimationOptionTransitionCrossDissolve
                    animations:^{
                        self.label.text = @&quot;Well done!&quot;;
                    } completion:nil];</code></pre></div>

<blockquote>
<p>方法三</p>
</blockquote>

<div><pre><code class="language-none">[UIView animateWithDuration:1.0
                     animations:^{
                         self.label.alpha = 0.0f;
                         self.label.text = @&quot;newText&quot;;
                         self.label.alpha = 1.0f;
                     }];</code></pre></div>

<h2 id="toc_29">30、判断字典中是否包含某个key值</h2>

<div><pre><code class="language-none">if ([dic objectForKey:@&quot;yourKey&quot;]) {
    NSLog(@&quot;有这个值&quot;);
} else {
    NSLog(@&quot;没有这个值&quot;);
}</code></pre></div>

<h2 id="toc_30">31、获取屏幕方向</h2>

<div><pre><code class="language-none">UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;

if(orientation == 0) //Default orientation 
    //默认
else if(orientation == UIInterfaceOrientationPortrait)
    //竖屏
else if(orientation == UIInterfaceOrientationLandscapeLeft)
    // 左横屏
else if(orientation == UIInterfaceOrientationLandscapeRight)
    //右横屏</code></pre></div>

<h2 id="toc_31">32、设置UIImage的透明度</h2>

<blockquote>
<p>方法一、添加UIImage分类</p>
</blockquote>

<div><pre><code class="language-none">- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);

    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);

    CGContextScaleCTM(ctx, 1, -1);
    CGContextTranslateCTM(ctx, 0, -area.size.height);

    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);

    CGContextSetAlpha(ctx, alpha);

    CGContextDrawImage(ctx, area, self.CGImage);

    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();

    return newImage;
}</code></pre></div>

<blockquote>
<p>方法二、如果没有奇葩需求，干脆用UIImageView设置透明度</p>
</blockquote>

<div><pre><code class="language-none">UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@&quot;yourImage&quot;]];
imageView.alpha = 0.5;</code></pre></div>

<h2 id="toc_32">33、Attempt to mutate immutable object with insertString:atIndex:</h2>

<p>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</p>

<h2 id="toc_33">34、UIWebView添加单击手势不响应</h2>

<div><pre><code class="language-none">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];
        tap.delegate = self;
        [_webView addGestureRecognizer:tap];</code></pre></div>

<blockquote>
<p>因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法</p>
</blockquote>

<div><pre><code class="language-none">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{
    return YES;
}</code></pre></div>

<h2 id="toc_34">35、获取手机RAM容量</h2>

<blockquote>
<p>需要导入#import</p>
</blockquote>

<div><pre><code class="language-none">mach_port_t host_port;
    mach_msg_type_number_t host_size;
    vm_size_t pagesize;

    host_port = mach_host_self();
    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);
    host_page_size(host_port, &amp;pagesize);

    vm_statistics_data_t vm_stat;

    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) {
        NSLog(@&quot;Failed to fetch vm statistics&quot;);
    }

    /* Stats in bytes */
    natural_t mem_used = (vm_stat.active_count +
                          vm_stat.inactive_count +
                          vm_stat.wire_count) * pagesize;
    natural_t mem_free = vm_stat.free_count * pagesize;
    natural_t mem_total = mem_used + mem_free;
    NSLog(@&quot;已用: %u 可用: %u 总共: %u&quot;, mem_used, mem_free, mem_total);</code></pre></div>

<h2 id="toc_35">36、地图上两个点之间的实际距离</h2>

<blockquote>
<p>需要导入#import</p>
</blockquote>

<div><pre><code class="language-none">CLLocation *locA = [[CLLocation alloc] initWithLatitude:34 longitude:113];
    CLLocation *locB = [[CLLocation alloc] initWithLatitude:31.05 longitude:121.76];
// CLLocationDistance求出的单位为米
    CLLocationDistance distance = [locA distanceFromLocation:locB];</code></pre></div>

<h2 id="toc_36">37、在应用中打开设置的某个界面</h2>

<blockquote>
<p>打开设置-&gt;通用</p>
</blockquote>

<div><pre><code class="language-none">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=General&quot;]];</code></pre></div>

<blockquote>
<p>以下是设置其他界面</p>
</blockquote>

<div><pre><code class="language-none">prefs:root=General&amp;path=About
prefs:root=General&amp;path=ACCESSIBILITY
prefs:root=AIRPLANE_MODE
prefs:root=General&amp;path=AUTOLOCK
prefs:root=General&amp;path=USAGE/CELLULAR_USAGE
prefs:root=Brightness
prefs:root=Bluetooth
prefs:root=General&amp;path=DATE_AND_TIME
prefs:root=FACETIME
prefs:root=General
prefs:root=General&amp;path=Keyboard
prefs:root=CASTLE
prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP
prefs:root=General&amp;path=INTERNATIONAL
prefs:root=LOCATION_SERVICES
prefs:root=ACCOUNT_SETTINGS
prefs:root=MUSIC
prefs:root=MUSIC&amp;path=EQ
prefs:root=MUSIC&amp;path=VolumeLimit
prefs:root=General&amp;path=Network
prefs:root=NIKE_PLUS_IPOD
prefs:root=NOTES
prefs:root=NOTIFICATIONS_ID
prefs:root=Phone
prefs:root=Photos
prefs:root=General&amp;path=ManagedConfigurationList
prefs:root=General&amp;path=Reset
prefs:root=Sounds&amp;path=Ringtone
prefs:root=Safari
prefs:root=General&amp;path=Assistant
prefs:root=Sounds
prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK
prefs:root=STORE
prefs:root=TWITTER
prefs:root=FACEBOOK
prefs:root=General&amp;path=USAGE prefs:root=VIDEO
prefs:root=General&amp;path=Network/VPN
prefs:root=Wallpaper
prefs:root=WIFI
prefs:root=INTERNET_TETHERING
prefs:root=Phone&amp;path=Blocked
prefs:root=DO_NOT_DISTURB</code></pre></div>

<h2 id="toc_37">38、在UITextView中显示html文本</h2>

<div><pre><code class="language-none">UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 30, 100, 199)];
textView.backgroundColor = [UIColor redColor];
[self.view addSubview:textView];
NSString *htmlString = @&quot;

NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options: @{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes: nil error: nil];
textView.attributedText = attributedString;</code></pre></div>

<h2 id="toc_38">39、监听scrollView是否滚动到了顶部／底部</h2>

<div><pre><code class="language-none">-(void)scrollViewDidScroll: (UIScrollView*)scrollView
{
float scrollViewHeight = scrollView.frame.size.height;
float scrollContentSizeHeight = scrollView.contentSize.height;
float scrollOffset = scrollView.contentOffset.y;

if (scrollOffset == 0)
{
    // 滚动到了顶部
}
else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight)
{
    // 滚动到了底部
}
}</code></pre></div>

<h2 id="toc_39">40、UISlider增量／减量为固定值(假如为5)</h2>

<div><pre><code class="language-none">- (void)setupSlider
{
    UISlider *slider = [[UISlider alloc] init];
    [self.view addSubview:slider];
    [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged];
    slider.maximumValue = 100;
    slider.minimumValue = 0;
    slider.frame = CGRectMake(200, 20, 100, 30);
}

- (void)sliderAction:(UISlider *)slider
{
    [slider setValue:((int)((slider.value + 2.5) / 5) * 5) animated:NO];
}</code></pre></div>

<h2 id="toc_40">41、选中textField或者textView所有文本(我这里以textView为例)</h2>

<div><pre><code class="language-none">[self.textView setSelectedTextRange:[self.textView textRangeFromPosition:self.textView.beginningOfDocument toPosition:self.textView.endOfDocument]]</code></pre></div>

<h2 id="toc_41">42、从导航控制器中删除某个控制器</h2>

<blockquote>
<p>方法一、知道这个控制器所处的导航控制器下标</p>
</blockquote>

<div><pre><code class="language-none">NSMutableArray *navigationArray = [[NSMutableArray alloc] initWithArray: self.navigationController.viewControllers];
[navigationArray removeObjectAtIndex: 2]; 
self.navigationController.viewControllers = navigationArray;</code></pre></div>

<blockquote>
<p>方法二、知道具体是哪个控制器</p>
</blockquote>

<div><pre><code class="language-none">NSArray* tempVCA = [self.navigationController viewControllers];

for(UIViewController *tempVC in tempVCA)
{
    if([tempVC isKindOfClass:[urViewControllerClass class]])
    {
        [tempVC removeFromParentViewController];
    }
}</code></pre></div>

<h2 id="toc_42">43、隐藏UITextView/UITextField光标</h2>

<div><pre><code class="language-none">textField.tintColor = [UIColor clearColor];</code></pre></div>

<h2 id="toc_43">44、当UITextView/UITextField中没有文字时，禁用回车键</h2>

<div><pre><code class="language-none">textField.enablesReturnKeyAutomatically = YES;</code></pre></div>

<h2 id="toc_44">45、字符串encode编码(编码url字符串不成功的问题)</h2>

<blockquote>
<p>我们一般用这个方法处理stringByAddingPercentEscapesUsingEncoding但是这个方法好想不会处理／和&amp;这种特殊符号，这种情况就需要用下边这个方法处理</p>
</blockquote>

<div><pre><code class="language-none">@implementation NSString (NSString_Extended)
- (NSString *)urlencode {
    NSMutableString *output = [NSMutableString string];
    const unsigned char *source = (const unsigned char *)[self UTF8String];
    int sourceLen = strlen((const char *)source);
    for (int i = 0; i &lt; sourceLen; ++i) {
        const unsigned char thisChar = source[i];
        if (thisChar == &#39; &#39;){
            [output appendString:@&quot;+&quot;];
        } else if (thisChar == &#39;.&#39; || thisChar == &#39;-&#39; || thisChar == &#39;_&#39; || thisChar == &#39;~&#39; || 
                   (thisChar &gt;= &#39;a&#39; &amp;&amp; thisChar = &#39;A&#39; &amp;&amp; thisChar = &#39;0&#39; &amp;&amp; thisChar &lt;= &#39;9&#39;)) {
            [output appendFormat:@&quot;%c&quot;, thisChar];
        } else {
            [output appendFormat:@&quot;%%X&quot;, thisChar];
        }
    }
    return output;
}</code></pre></div>

<h2 id="toc_45">46、计算UILabel上某段文字的frame</h2>

<div><pre><code class="language-none">@implementation UILabel (TextRect)

- (CGRect)boundingRectForCharacterRange:(NSRange)range
{
    NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:[self attributedText]];
    NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];
    [textStorage addLayoutManager:layoutManager];
    NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:[self bounds].size];
    textContainer.lineFragmentPadding = 0;
    [layoutManager addTextContainer:textContainer];
    NSRange glyphRange;
    [layoutManager characterRangeForGlyphRange:range actualGlyphRange:&amp;glyphRange];
    return [layoutManager boundingRectForGlyphRange:glyphRange inTextContainer:textContainer];
}</code></pre></div>

<p>47、获取随机UUID</p>

<div><pre><code class="language-none">NSString *result;
    if([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 6.0)
    {
       result = [[NSUUID UUID] UUIDString];
    }
    else
    {
        CFUUIDRef uuidRef = CFUUIDCreate(NULL);
        CFStringRef uuid = CFUUIDCreateString(NULL, uuidRef);
        CFRelease(uuidRef);
        result = (__bridge_transfer NSString *)uuid;
    }</code></pre></div>

<h2 id="toc_46">48、仿苹果抖动动画</h2>

<div><pre><code class="language-none">#define RADIANS(degrees) (((degrees) * M_PI) / 180.0)

- (void)startAnimate {
    view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(-5));
    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionRepeat | UIViewAnimationOptionAutoreverse) animations:^ {
                         view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(5));
                     } completion:nil];
}

- (void)stopAnimate {
    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveLinear) animations:^ {
                         view.transform = CGAffineTransformIdentity;
                     } completion:nil];
}</code></pre></div>

<h2 id="toc_47">49、修改UISearBar内部背景颜色</h2>

<div><pre><code class="language-none">UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];
textField.backgroundColor = [UIColor redColor];</code></pre></div>

<h2 id="toc_48">50、UITextView滚动到顶部</h2>

<blockquote>
<p>方法一</p>
</blockquote>

<div><pre><code class="language-none">[self.textView scrollRangeToVisible:NSMakeRange(0, 0)];</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">[self.textView setContentOffset:CGPointZero animated:YES];</code></pre></div>

<h2 id="toc_49">51、通知监听APP生命周期</h2>

<div><pre><code class="language-none">UIApplicationDidEnterBackgroundNotification 应用程序进入后台
UIApplicationWillEnterForegroundNotification 应用程序将要进入前台
UIApplicationDidFinishLaunchingNotification 应用程序完成启动
UIApplicationDidFinishLaunchingNotification 应用程序由挂起变的活跃
UIApplicationWillResignActiveNotification 应用程序挂起(有电话进来或者锁屏)
UIApplicationDidReceiveMemoryWarningNotification 应用程序收到内存警告
UIApplicationDidReceiveMemoryWarningNotification 应用程序终止(后台杀死、手机关机等)
UIApplicationSignificantTimeChangeNotification 当有重大时间改变(凌晨0点，设备时间被修改，时区改变等)
UIApplicationWillChangeStatusBarOrientationNotification 设备方向将要改变
UIApplicationDidChangeStatusBarOrientationNotification 设备方向改变
UIApplicationWillChangeStatusBarFrameNotification 设备状态栏frame将要改变
UIApplicationDidChangeStatusBarFrameNotification 设备状态栏frame改变
UIApplicationBackgroundRefreshStatusDidChangeNotification 应用程序在后台下载内容的状态发生变化
UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件被锁定,无法访问
UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件可用了</code></pre></div>

<h2 id="toc_50">52、触摸事件类型</h2>

<div><pre><code class="language-none">UIControlEventTouchCancel 取消控件当前触发的事件
UIControlEventTouchDown 点按下去的事件
UIControlEventTouchDownRepeat 重复的触动事件
UIControlEventTouchDragEnter 手指被拖动到控件的边界的事件
UIControlEventTouchDragExit 一个手指从控件内拖到外界的事件
UIControlEventTouchDragInside 手指在控件的边界内拖动的事件
UIControlEventTouchDragOutside 手指在控件边界之外被拖动的事件
UIControlEventTouchUpInside 手指处于控制范围内的触摸事件
UIControlEventTouchUpOutside 手指超出控制范围的控制中的触摸事件</code></pre></div>

<h2 id="toc_51">53、UITextField文字周围增加边距</h2>

<blockquote>
<p>子类化UITextField，增加insert属性</p>
</blockquote>

<div><pre><code class="language-none">@interface WZBTextField : UITextField
@property (nonatomic, assign) UIEdgeInsets insets;
@end</code></pre></div>

<blockquote>
<p>在.m文件重写下列方法</p>
</blockquote>

<div><pre><code class="language-none">- (CGRect)textRectForBounds:(CGRect)bounds {
    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);
    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {
        return [self adjustRectWithWidthRightView:paddedRect];
    }
    return paddedRect;
}

- (CGRect)placeholderRectForBounds:(CGRect)bounds {
    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);

    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {
        return [self adjustRectWithWidthRightView:paddedRect];
    }
    return paddedRect;
}

- (CGRect)editingRectForBounds:(CGRect)bounds {
    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);
    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeWhileEditing) {
        return [self adjustRectWithWidthRightView:paddedRect];
    }
    return paddedRect;
}

- (CGRect)adjustRectWithWidthRightView:(CGRect)bounds {
    CGRect paddedRect = bounds;
    paddedRect.size.width -= CGRectGetWidth(self.rightView.frame);

    return paddedRect;
}</code></pre></div>

<h2 id="toc_52">54、监听UISlider拖动状态</h2>

<blockquote>
<p>添加事件</p>
</blockquote>

<div><pre><code class="language-none">[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];</code></pre></div>

<blockquote>
<p>实现方法</p>
</blockquote>

<div><pre><code class="language-none">- (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event {
    UITouch *touchEvent = [[event allTouches] anyObject];
    switch (touchEvent.phase) {
        case UITouchPhaseBegan:
            NSLog(@&quot;开始拖动&quot;);
            break;
        case UITouchPhaseMoved:
            NSLog(@&quot;正在拖动&quot;);
            break;
        case UITouchPhaseEnded:
            NSLog(@&quot;结束拖动&quot;);
            break;
        default:
            break;
    }
}</code></pre></div>

<h2 id="toc_53">55、设置UITextField光标位置</h2>

<blockquote>
<p>textField需要设置的textField，index要设置的光标位置</p>
</blockquote>

<div><pre><code class="language-none">- (void)cursorLocation:(UITextField *)textField index:(NSInteger)index
{
    NSRange range = NSMakeRange(index, 0);
    UITextPosition *start = [textField positionFromPosition:[textField beginningOfDocument] offset:range.location];
    UITextPosition *end = [textField positionFromPosition:start offset:range.length];
    [textField setSelectedTextRange:[textField textRangeFromPosition:start toPosition:end]];
}</code></pre></div>

<h2 id="toc_54">56、去除webView底部黑色</h2>

<div><pre><code class="language-none">[webView setBackgroundColor:[UIColor clearColor]];
[webView setOpaque:NO];

for (UIView *v1 in [webView subviews])
{
    if ([v1 isKindOfClass:[UIScrollView class]])
    {
        for (UIView *v2 in v1.subviews)
        {
            if ([v2 isKindOfClass:[UIImageView class]])
            {
                v2.hidden = YES;
            }
        }
    }
}</code></pre></div>

<h2 id="toc_55">57、获取collectionViewCell在屏幕中的frame</h2>

<div><pre><code class="language-none">UICollectionViewLayoutAttributes *attributes = [collectionView layoutAttributesForItemAtIndexPath:indexPath];
CGRect cellRect = attributes.frame;
CGRect cellFrameInSuperview = [collectionView convertRect:cellRect toView:[cv superview]];</code></pre></div>

<h2 id="toc_56">58、比较两个UIImage是否相等</h2>

<div><pre><code class="language-none">- (BOOL)image:(UIImage *)image1 isEqualTo:(UIImage *)image2
{
    NSData *data1 = UIImagePNGRepresentation(image1);
    NSData *data2 = UIImagePNGRepresentation(image2);

    return [data1 isEqual:data2];
}</code></pre></div>

<h2 id="toc_57">59、解决当UIScrollView上有UIButton的时候，触摸到button滑动不了的问题</h2>

<blockquote>
<p>子类化UIScrollView，并重写以下方法</p>
</blockquote>

<div><pre><code class="language-none">- (instancetype)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        self.delaysContentTouches = NO;
    }

    return self;
}

- (BOOL)touchesShouldCancelInContentView:(UIView *)view {
    if ([view isKindOfClass:UIButton.class]) {
        return YES;
    }

    return [super touchesShouldCancelInContentView:view];
}</code></pre></div>

<h2 id="toc_58">60、UITextView中的文字添加阴影效果</h2>

<div><pre><code class="language-none">- (void)setTextLayer:(UITextView *)textView color:(UIColor *)color
{
    CALayer *textLayer = ((CALayer *)[textView.layer.sublayers objectAtIndex:0]);
    textLayer.shadowColor = color.CGColor;
    textLayer.shadowOffset = CGSizeMake(0.0f, 1.0f);
    textLayer.shadowOpacity = 1.0f;
    textLayer.shadowRadius = 1.0f;
}</code></pre></div>

<h2 id="toc_59">61、MD5加密</h2>

<div><pre><code class="language-none">+ (NSString *)md5:(NSString *)str
{
    const char *concat_str = [str UTF8String];
    unsigned char result[CC_MD5_DIGEST_LENGTH];
    CC_MD5(concat_str, (unsigned int)strlen(concat_str), result);
    NSMutableString *hash = [NSMutableString string];
    for (int i =0; i&lt;16; i++){
        [hash appendFormat:@&quot;X&quot;, result[i]];
    }
    return [hash uppercaseString];
}</code></pre></div>

<h2 id="toc_60">62、base64加密</h2>

<div><pre><code class="language-none">@interface NSData (Base64)
/**
 *  @brief  字符串base64后转data
 */
+ (NSData *)dataWithBase64EncodedString:(NSString *)string
{
    if (![string length]) return nil;
    NSData *decoded = nil;
#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
    if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)])
    {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
        decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]];
#pragma clang diagnostic pop
    }
    else
#endif
    {
        decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters];
    }
    return [decoded length]? decoded: nil;
}
/**
 *  @brief  NSData转string
 *  @param wrapWidth 换行长度  76  64
 */
- (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth
{
    if (![self length]) return nil;
    NSString *encoded = nil;
#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
    if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)])
    {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
        encoded = [self base64Encoding];
#pragma clang diagnostic pop

    }
    else
#endif
    {
        switch (wrapWidth)
        {
            case 64:
            {
                return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
            }
            case 76:
            {
                return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength];
            }
            default:
            {
                encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
            }
        }
    }
    if (!wrapWidth || wrapWidth &gt;= [encoded length])
    {
        return encoded;
    }
    wrapWidth = (wrapWidth / 4) * 4;
    NSMutableString *result = [NSMutableString string];
    for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth)
    {
        if (i + wrapWidth &gt;= [encoded length])
        {
            [result appendString:[encoded substringFromIndex:i]];
            break;
        }
        [result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]];
        [result appendString:@&quot;\r\n&quot;];
    }
    return result;
}
/**
 *  @brief  NSData转string 换行长度默认64
 */
- (NSString *)base64EncodedString
{
    return [self base64EncodedStringWithWrapWidth:0];
}</code></pre></div>

<h2 id="toc_61">63、AES加密</h2>

<div><pre><code class="language-none">#import
@interface NSData (AES)
/**
 *  利用AES加密数据
 */
- (NSData*)encryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv {

    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t dataMoved;
    NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128];

    CCCryptorStatus status = CCCrypt(kCCEncrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes, encryptedData.length,&amp;dataMoved);

    if (status == kCCSuccess) {
        encryptedData.length = dataMoved;
        return encryptedData;
    }

    return nil;
}

/**
 *  @brief  利用AES解密据
 */
- (NSData*)decryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv {

    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t dataMoved;
    NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128];

    CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes, decryptedData.length,&amp;dataMoved);

    if (result == kCCSuccess) {
        decryptedData.length = dataMoved;
        return decryptedData;
    }

    return nil;

}</code></pre></div>

<h2 id="toc_62">64、3DES加密</h2>

<div><pre><code class="language-none">#import
@interface NSData (3DES)
/**
 *  利用3DES加密数据
 */
- (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t dataMoved;
    NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

    CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved);

    if (result == kCCSuccess) {
        encryptedData.length = dataMoved;
        return encryptedData;
    }

    return nil;

}
/**
 *  @brief   利用3DES解密数据
 */
- (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t dataMoved;
    NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

    CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved);

    if (result == kCCSuccess) {
        decryptedData.length = dataMoved;
        return decryptedData;
    }

    return nil;

}</code></pre></div>

<h2 id="toc_63">65、单个页面多个网络请求的情况，需要监听所有网络请求结束后刷新UI</h2>

<div><pre><code class="language-none">dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_group_enter(group);
    dispatch_group_async(group, serialQueue, ^{
        // 网络请求一
        [WebClick getDataSuccess:^(ResponseModel *model) {
            dispatch_group_leave(group);
        } failure:^(NSString *err) {
            dispatch_group_leave(group);
        }];
    });
    dispatch_group_enter(group);
    dispatch_group_async(group, serialQueue, ^{
        // 网络请求二
        [WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) {
            dispatch_group_leave(group);
        }                                  failure:^(NSString *errorString) {
            dispatch_group_leave(group);
        }];
    });
    dispatch_group_enter(group);
    dispatch_group_async(group, serialQueue, ^{
        // 网络请求三
        [WebClick getDataSuccess:^{
            dispatch_group_leave(group);
        } failure:^(NSString *errorString) {
            dispatch_group_leave(group);
        }];
    });

    // 所有网络请求结束后会来到这个方法
    dispatch_group_notify(group, serialQueue, ^{
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            dispatch_async(dispatch_get_main_queue(), ^{
                // 刷新UI
            });
        });
    });</code></pre></div>

<h2 id="toc_64">66、解决openUrl延时问题</h2>

<blockquote>
<p>方法一</p>
</blockquote>

<div><pre><code class="language-none">dispatch_async(dispatch_get_main_queue(), ^{

    UIApplication *application = [UIApplication sharedApplication];
    if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {
        [application openURL:URL options:@{}
           completionHandler:nil];
    } else {
        [application openURL:URL];
    }
    });</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">[self performSelector:@selector(redirectToURL:) withObject:url afterDelay:0.1];

- (void) redirectToURL
{
UIApplication *application = [UIApplication sharedApplication];
    if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {
        [application openURL:URL options:@{}
           completionHandler:nil];
    } else {
        [application openURL:URL];
    }
}</code></pre></div>

<h2 id="toc_65">67、页面跳转实现翻转动画</h2>

<blockquote>
<p>modal方式</p>
</blockquote>

<div><pre><code class="language-none">TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical;
[self presentViewController:vc animated:YES completion:nil];</code></pre></div>

<blockquote>
<p>push方式</p>
</blockquote>

<div><pre><code class="language-none">TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
[UIView beginAnimations:@&quot;View Flip&quot; context:nil];
[UIView setAnimationDuration:0.80];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO];
[self.navigationController pushViewController:vc animated:YES];
[UIView commitAnimations];</code></pre></div>

<h2 id="toc_66">68、tableView实现无限滚动</h2>

<div><pre><code class="language-none">- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat actualPosition = scrollView.contentOffset.y;
    CGFloat contentHeight = scrollView.contentSize.height - scrollView.frame.size.height;
    if (actualPosition &gt;= contentHeight) {
        [self.dataArr addObjectsFromArray:self.dataArr];
        [self.tableView reloadData];
    }
}</code></pre></div>

<h2 id="toc_67">69、代码方式调整屏幕亮度</h2>

<div><pre><code class="language-none">// brightness属性值在0-1之间，0代表最小亮度，1代表最大亮度
[[UIScreen mainScreen] setBrightness:0.5];</code></pre></div>

<h2 id="toc_68">70、获取当前应用CUP用量</h2>

<div><pre><code class="language-none">float cpu_usage()
{
    kern_return_t kr;
    task_info_data_t tinfo;
    mach_msg_type_number_t task_info_count;

    task_info_count = TASK_INFO_MAX;
    kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);
    if (kr != KERN_SUCCESS) {
        return -1;
    }

    task_basic_info_t      basic_info;
    thread_array_t         thread_list;
    mach_msg_type_number_t thread_count;

    thread_info_data_t     thinfo;
    mach_msg_type_number_t thread_info_count;

    thread_basic_info_t basic_info_th;
    uint32_t stat_thread = 0; // Mach threads

    basic_info = (task_basic_info_t)tinfo;

    // get threads in the task
    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    if (thread_count &gt; 0)
        stat_thread += thread_count;

    long tot_sec = 0;
    long tot_usec = 0;
    float tot_cpu = 0;
    int j;

    for (j = 0; j &lt; (int)thread_count; j++)
    {
        thread_info_count = THREAD_INFO_MAX;
        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,
                         (thread_info_t)thinfo, &amp;thread_info_count);
        if (kr != KERN_SUCCESS) {
            return -1;
        }

        basic_info_th = (thread_basic_info_t)thinfo;

        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) {
            tot_sec = tot_sec + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;
            tot_usec = tot_usec + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;
            tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;
        }

    } // for each thread

    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));
    assert(kr == KERN_SUCCESS);

    return tot_cpu;
}</code></pre></div>

<h2 id="toc_69">71、float数据取整四舍五入</h2>

<div><pre><code class="language-none">CGFloat f = 4.65;
NSLog(@&quot;%d&quot;, (int)f);    // 打印结果4

CGFloat f = 4.65;
NSLog(@&quot;%d&quot;, (int)round(f));    // 打印结果5</code></pre></div>

<h2 id="toc_70">72、删除UISearchBar系统默认边框</h2>

<blockquote>
<p>方法一</p>
</blockquote>

<div><pre><code class="language-none">searchBar.searchBarStyle = UISearchBarStyleMinimal;</code></pre></div>

<blockquote>
<p>方法二</p>
</blockquote>

<div><pre><code class="language-none">[searchBar setBackgroundImage:[[UIImage alloc]init]];</code></pre></div>

<blockquote>
<p>方法三</p>
</blockquote>

<div><pre><code class="language-none">searchBar.barTintColor = [UIColor whiteColor];</code></pre></div>

<h2 id="toc_71">73、为UICollectionViewCell设置圆角和阴影</h2>

<div><pre><code class="language-none">cell.contentView.layer.cornerRadius = 2.0f;
cell.contentView.layer.borderWidth = 1.0f;
cell.contentView.layer.borderColor = [UIColor clearColor].CGColor;
cell.contentView.layer.masksToBounds = YES;

cell.layer.shadowColor = [UIColor lightGrayColor].CGColor;
cell.layer.shadowOffset = CGSizeMake(0, 2.0f);
cell.layer.shadowRadius = 2.0f;
cell.layer.shadowOpacity = 1.0f;
cell.layer.masksToBounds = NO;
cell.layer.shadowPath = [UIBezierPath bezierPathWithRoundedRect:cell.bounds cornerRadius:cell.contentView.layer.cornerRadius].CGPath;</code></pre></div>

<h2 id="toc_72">74、让正在滑动的scrollView停止滚动(不是禁止，而是暂时停止滚动)</h2>

<div><pre><code class="language-none">[scrollView setContentOffset:scrollView.contentOffset animated:NO];</code></pre></div>

<h2 id="toc_73">75、使用xib设置UIView的边框、圆角</h2>

<blockquote>
<p>圆角和边框看下图即可设置
<img src="http://cc.cocimg.com/api/uploads/20170710/1499658702959959.png" alt=""></p>

<p>但是增加layer.borderColor的keyPath设置边框颜色并不能起作用，后来查了资料，这里应该用layer.borderUIColor，但是这里设置的颜色不起作用，无论设置什么颜色显示出来的都是黑色的。后来又去查了下，有种解决方案是给CALayer添加一个分类，提供一个 - (void)setBorderUIColor:(UIColor *)color;方法就可以解决了，实现如下：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20170710/1499658718937739.png" alt=""></p>
</blockquote>

<div><pre><code class="language-none">#import &quot;CALayer+BorderColor.h&quot;

@implementation CALayer (BorderColor)

- (void)setBorderUIColor:(UIColor *)color
{
    self.borderColor = color.CGColor;
}</code></pre></div>

<h2 id="toc_74">76、根据经纬度获取城市等信息</h2>

<blockquote>
<p>创建经纬度</p>
</blockquote>

<div><pre><code class="language-none">CLLocation *location = [[CLLocation alloc] initWithLatitude:latitude longitude:longitude];
//创建一个译码器
CLGeocoder *cLGeocoder = [[CLGeocoder alloc] init];
[cLGeocoder reverseGeocodeLocation:userLocation completionHandler:^(NSArray *placemarks, NSError *error) {
    CLPlacemark *place = [placemarks objectAtIndex:0];
    // 位置名
　　NSLog(@&quot;name,%@&quot;,place.name);
　　// 街道
　　NSLog(@&quot;thoroughfare,%@&quot;,place.thoroughfare);
　　// 子街道
　　NSLog(@&quot;subThoroughfare,%@&quot;,place.subThoroughfare);
　　// 市
　　NSLog(@&quot;locality,%@&quot;,place.locality);
　　// 区
　　NSLog(@&quot;subLocality,%@&quot;,place.subLocality); 
　　// 国家
　　NSLog(@&quot;country,%@&quot;,place.country);
    }
}];

/*  CLPlacemark中属性含义
name                    地名

thoroughfare            街道

subThoroughfare        街道相关信息，例如门牌等
locality                城市

subLocality            城市相关信息，例如标志性建筑

administrativeArea      直辖市

subAdministrativeArea  其他行政区域信息（自治区等）

postalCode              邮编

ISOcountryCode          国家编码

country                国家

inlandWater            水源，湖泊

ocean                  海洋

areasOfInterest        关联的或利益相关的地标
*/</code></pre></div>

<h2 id="toc_75">77、如何防止添加多个NSNotification观察者？</h2>

<blockquote>
<p>解决方案就是添加观察者之前先移除下这个观察者</p>
</blockquote>

<div><pre><code class="language-none">[[NSNotificationCenter defaultCenter] removeObserver:observer name:name object:object];
[[NSNotificationCenter defaultCenter] addObserver:observer selector:selector name:name object:object];</code></pre></div>

<h2 id="toc_76">78、将一个xib添加到另外一个xib上</h2>

<blockquote>
<p>假设你的自定义view名字为CustomView，你需要在CustomView.m中重写 <code>- (instancetype)initWithCoder:(NSCoder *)aDecoder</code> 方法，代码如下：</p>
</blockquote>

<div><pre><code class="language-none">- (instancetype)initWithCoder:(NSCoder *)aDecoder {
    if ((self = [super initWithCoder:aDecoder])) {
        [self addSubview:[[[NSBundle mainBundle] loadNibNamed:@&quot;CustomView&quot; owner:self options:nil] objectAtIndex:0]];
    }
    return self;</code></pre></div>

<p>}</p>

<p><img src="http://cc.cocimg.com/api/uploads/20170710/1499658806305115.png" alt=""></p>

<h2 id="toc_77">79、处理字符串，使其首字母大写</h2>

<div><pre><code class="language-none">NSString *str = @&quot;abcdefghijklmn&quot;;
NSString *resultStr;
if (str &amp;&amp; str.length &gt; 0) {
    resultStr = [str stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[str substringToIndex:1] capitalizedString]];
}
NSLog(@&quot;%@&quot;, resultStr);</code></pre></div>

<h2 id="toc_78">80、判断一个UIAlertView/UIAlertController是否显示</h2>

<blockquote>
<p>UIAlertView自带属性</p>
</blockquote>

<div><pre><code class="language-none">if (alert.visible)
{
      NSLog(@&quot;显示了&quot;);
} else {
      NSLog(@&quot;未显示&quot;);
}</code></pre></div>

<blockquote>
<p>UIAlertController没有visible属性，需要自己判断，添加一个全局变量 BOOL visible</p>
</blockquote>

<div><pre><code class="language-none">UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;Title&quot; message:@&quot;message&quot; preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *alertAction = [UIAlertAction actionWithTitle:@&quot;ActionTitle&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        self.visible = NO;
    }];
    UIAlertAction *calcelAction = [UIAlertAction actionWithTitle:@&quot;calcelTitle&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
        self.visible = NO;
    }];
    [alertController addAction:alertAction];
    [alertController addAction:calcelAction];
    [self presentViewController:alertController animated:YES completion:^{
        self.visible = YES;
    }];</code></pre></div>

<h2 id="toc_79">81、获取字符串中的数字</h2>

<div><pre><code class="language-none">- (NSString *)getNumberFromStr:(NSString *)str
{
    NSCharacterSet *nonDigitCharacterSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    return [[str componentsSeparatedByCharactersInSet:nonDigitCharacterSet] componentsJoinedByString:@&quot;&quot;];
}
6
    NSLog(@&quot;%@&quot;, [self getNumberFromStr:@&quot;a0b0c1d2e3f4fda8fa8fad9fsad23&quot;]); // 00123488923</code></pre></div>

<h2 id="toc_80">82、为UIView的某个方向添加边框</h2>

<blockquote>
<p>添加UIView分类</p>

<p>UIView+WZB.h</p>
</blockquote>

<div><pre><code class="language-none">#import


/**
 边框方向

 - WZBBorderDirectionTop: 顶部
 - WZBBorderDirectionLeft: 左边
 - WZBBorderDirectionBottom: 底部
 - WZBBorderDirectionRight: 右边
 */
typedef NS_ENUM(NSInteger, WZBBorderDirectionType) {
    WZBBorderDirectionTop = 0,
    WZBBorderDirectionLeft,
    WZBBorderDirectionBottom,
    WZBBorderDirectionRight
};

@interface UIView (WZB)


/**
 为UIView的某个方向添加边框

 @param direction 边框方向
 @param color 边框颜色
 @param width 边框宽度
 */
- (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width;

@end

// UIView+WZB.m
#import &quot;UIView+WZB.h&quot;

@implementation UIView (WZB)

- (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width
{
    CALayer *border = [CALayer layer];
    border.backgroundColor = color.CGColor;
    switch (direction) {
        case WZBBorderDirectionTop:
        {
            border.frame = CGRectMake(0.0f, 0.0f, self.bounds.size.width, width);
        }
            break;
        case WZBBorderDirectionLeft:
        {
            border.frame = CGRectMake(0.0f, 0.0f, width, self.bounds.size.height);
        }
            break;
        case WZBBorderDirectionBottom:
        {
            border.frame = CGRectMake(0.0f, self.bounds.size.height - width, self.bounds.size.width, width);
        }
            break;
        case WZBBorderDirectionRight:
        {
            border.frame = CGRectMake(self.bounds.size.width - width, 0, width, self.bounds.size.height);
        }
            break;
        default:
            break;
    }
    [self.layer addSublayer:border];
}</code></pre></div>

<h2 id="toc_81">83、通过属性设置UISwitch、UIProgressView等控件的宽高</h2>

<div><pre><code class="language-none">mySwitch.transform = CGAffineTransformMakeScale(5.0f, 5.0f);

progressView.transform = CGAffineTransformMakeScale(5.0f, 5.0f);</code></pre></div>

<h2 id="toc_82">84、自动搜索功能，用户连续输入的时候不搜索，用户停止输入的时候自动搜索(我这里设置的是0.5s，可根据需求更改)</h2>

<blockquote>
<p>输入框文字改变的时候调用</p>
</blockquote>

<div><pre><code class="language-none">-(void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText{
    // 先取消调用搜索方法
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(searchNewResult) object:nil];
    // 0.5秒后调用搜索方法
    [self performSelector:@selector(searchNewResult) withObject:nil afterDelay:0.5];
}</code></pre></div>

<h2 id="toc_83">85、修改UISearchBar的占位文字颜色</h2>

<blockquote>
<p>方法一（推荐使用）</p>
</blockquote>

<div><pre><code class="language-none">UITextField *searchField = [searchBar valueForKey:@&quot;_searchField&quot;];
[searchField setValue:[UIColor blueColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</code></pre></div>

<blockquote>
<p>方法二（已过期）</p>
</blockquote>

<div><pre><code class="language-none">[[UILabel appearanceWhenContainedIn:[UISearchBar class], nil] setTextColor:[UIColor redColor]];</code></pre></div>

<blockquote>
<p>方法三（已过期）</p>
</blockquote>

<div><pre><code class="language-none">NSDictionary *placeholderAttributes = @{NSForegroundColorAttributeName : [UIColor redColor], NSFontAttributeName : [UIFont fontWithName:@&quot;HelveticaNeue&quot; size:15],};
NSAttributedString *attributedPlaceholder = [[NSAttributedString alloc] initWithString:searchBar.placeholder attributes:placeholderAttributes];
[[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setAttributedPlaceholder:attributedPlaceholder];</code></pre></div>

<h2 id="toc_84">86、某个界面多个事件同时响应引起的问题(比如，两个button同时按push到新界面，两个都会响应，可能导致push重叠)</h2>

<blockquote>
<p>UIView有个属性叫做exclusiveTouch，设置为YES后，其响应事件会和其他view互斥(有其他view事件响应的时候点击它不起作用)
view.exclusiveTouch = YES;</p>

<p>一个一个设置太麻烦了，可以全局设置</p>
</blockquote>

<div><pre><code class="language-none"> [[UIView appearance] setExclusiveTouch:YES];</code></pre></div>

<blockquote>
<p>或者只设置button</p>
</blockquote>

<div><pre><code class="language-none">[[UIButton appearance] setExclusiveTouch:YES];</code></pre></div>

<h2 id="toc_85">87、修改tabBar的frame</h2>

<blockquote>
<p>子类化UITabBarViewController，我这里以修改tabBar高度为例，重写viewWillLayoutSubviews方法</p>
</blockquote>

<div><pre><code class="language-none">#import &quot;WZBTabBarViewController.h&quot;

@interface WZBTabBarViewController ()

@end

@implementation WZBTabBarViewController
- (void)viewWillLayoutSubviews {

    CGRect tabFrame = self.tabBar.frame;
    tabFrame.size.height = 100;
    tabFrame.origin.y = self.view.frame.size.height - 100;
    self.tabBar.frame = tabFrame;
}
@end</code></pre></div>

<h2 id="toc_86">88、修改键盘背景颜色</h2>

<blockquote>
<p>设置某个键盘颜色</p>
</blockquote>

<div><pre><code class="language-none">textField.keyboardAppearance = UIKeyboardAppearanceAlert;</code></pre></div>

<blockquote>
<p>设置工程中所有键盘颜色</p>
</blockquote>

<div><pre><code class="language-none">[[UITextField appearance] setKeyboardAppearance:UIKeyboardAppearanceAlert];</code></pre></div>

<h2 id="toc_87">89、修改image颜色</h2>

<div><pre><code class="language-none">UIImage *image = [UIImage imageNamed:@&quot;test&quot;];
    imageView.image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
    CGRect rect = CGRectMake(0, 0, image.size.width, image.size.height);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextClipToMask(context, rect, image.CGImage);
    CGContextSetFillColorWithColor(context, [[UIColor redColor] CGColor]);
    CGContextFillRect(context, rect);
    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    UIImage *flippedImage = [UIImage imageWithCGImage:img.CGImage scale:1.0 orientation: UIImageOrientationDownMirrored];
    imageView.image = flippedImage;</code></pre></div>

<h2 id="toc_88">90、动画执行removeFromSuperview</h2>

<div><pre><code class="language-none">[UIView animateWithDuration:0.2
                 animations:^{
                     view.alpha = 0.0f;
                 } completion:^(BOOL finished){
                     [view removeFromSuperview];
                 }];</code></pre></div>

<h2 id="toc_89">91、设置UIButton高亮背景颜色</h2>

<div><pre><code class="language-none">[UIView animateWithDuration:0.2
                 animations:^{
                     view.alpha = 0.0f;
                 } completion:^(BOOL finished){
                     [view removeFromSuperview];
                 }];</code></pre></div>

<h2 id="toc_90">92、设置UIButton高亮时的背景颜色</h2>

<blockquote>
<p>方法一、子类化UIButton，重写setHighlighted:方法，代码如下</p>
</blockquote>

<div><pre><code class="language-none">#import &quot;WZBButton.h&quot;

@implementation WZBButton

- (void)setHighlighted:(BOOL)highlighted {
    [super setHighlighted:highlighted];

    UIColor *normalColor = [UIColor greenColor];
    UIColor *highlightedColor = [UIColor redColor];
    self.backgroundColor = highlighted ? highlightedColor : normalColor;

}</code></pre></div>

<blockquote>
<p>方法二、利用setBackgroundImage:forState:方法</p>
</blockquote>

<div><pre><code class="language-none">[button setBackgroundImage:[self imageWithColor:[UIColor blueColor]] forState:UIControlStateHighlighted];

- (UIImage *)imageWithColor:(UIColor *)color {
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();

    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);

    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return image;
}</code></pre></div>

<h2 id="toc_91">93、关于图片拉伸</h2>

<blockquote>
<p>推荐看这个博客，讲的很详细：http://blog.csdn.net/q199109106q/article/details/8615661</p>
</blockquote>

<h2 id="toc_92">94、利用runtime获取一个类所有属性</h2>

<div><pre><code class="language-none">- (NSArray *)allPropertyNames:(Class)aClass
{
    unsigned count;
    objc_property_t *properties = class_copyPropertyList(aClass, &amp;count);

    NSMutableArray *rv = [NSMutableArray array];

    unsigned i;
    for (i = 0; i &lt; count; i++)
    {
        objc_property_t property = properties[i];
        NSString *name = [NSString stringWithUTF8String:property_getName(property)];
        [rv addObject:name];
    }

    free(properties);

    return rv;
}</code></pre></div>

<h2 id="toc_93">95、设置textView的某段文字变成其他颜色</h2>

<div><pre><code class="language-none">- (void)setupTextView:(UITextView *)textView text:(NSString *)text color:(UIColor *)color {
    NSMutableAttributedString *string = [[NSMutableAttributedString alloc]initWithString:textView.text];
    [string addAttribute:NSForegroundColorAttributeName value:color range:[textView.text rangeOfString:text]];
    [textView setAttributedText:string];
}</code></pre></div>

<h2 id="toc_94">96、让push跳转动画像modal跳转动画那样效果(从下往上推上来)</h2>

<div><pre><code class="language-none">- (void)push
{
TestViewController *vc = [[TestViewController alloc] init];
    vc.view.backgroundColor = [UIColor redColor];
    CATransition* transition = [CATransition animation];
    transition.duration = 0.4f;
    transition.type = kCATransitionMoveIn;
    transition.subtype = kCATransitionFromTop;
    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];
    [self.navigationController pushViewController:vc animated:NO];
}

- (void)pop
{
CATransition* transition = [CATransition animation];
    transition.duration = 0.4f;
    transition.type = kCATransitionReveal;
    transition.subtype = kCATransitionFromBottom;
    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];
    [self.navigationController popViewControllerAnimated:NO];
}</code></pre></div>

<h2 id="toc_95">97、上传图片太大，压缩图片</h2>

<div><pre><code class="language-none">-(UIImage *)resizeImage:(UIImage *)image
{
    float actualHeight = image.size.height;
    float actualWidth = image.size.width;
    float maxHeight = 300.0;
    float maxWidth = 400.0;
    float imgRatio = actualWidth/actualHeight;
    float maxRatio = maxWidth/maxHeight;
    float compressionQuality = 0.5;//50 percent compression

    if (actualHeight &gt; maxHeight || actualWidth &gt; maxWidth)
    {
        if(imgRatio &lt; maxRatio)
        {
            //adjust width according to maxHeight
            imgRatio = maxHeight / actualHeight;
            actualWidth = imgRatio * actualWidth;
            actualHeight = maxHeight;
        }
        else if(imgRatio &gt; maxRatio)
        {
            //adjust height according to maxWidth
            imgRatio = maxWidth / actualWidth;
            actualHeight = imgRatio * actualHeight;
            actualWidth = maxWidth;
        }
        else
        {
            actualHeight = maxHeight;
            actualWidth = maxWidth;
        }
    }

    CGRect rect = CGRectMake(0.0, 0.0, actualWidth, actualHeight);
    UIGraphicsBeginImageContext(rect.size);
    [image drawInRect:rect];
    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();
    NSData *imageData = UIImageJPEGRepresentation(img, compressionQuality);
    UIGraphicsEndImageContext();

    return [UIImage imageWithData:imageData];

}</code></pre></div>




</body>

</html>
